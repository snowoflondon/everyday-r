---
title: "1. Data Wrangling"
output: html_notebook
---

## Everyday scenario

Suppose there exists a test dataset and the user is tasked with proving their proficiency in exploratory data analysis (EDA). However, prior to EDA the user must be able to transform the original data into a desirable format. This includes, but not limited to, missing data imputation, scalar transformation, feature selection, group aggregation, and data filtering. The following notebook outlines the fundamentals of data wrangling, using base R and `tidyverse` solutions interchangeably. 

```{r, echo=FALSE, warning=FALSE}
library(tidyverse)
```


## Solutions



### Renaming column headers

Suppose a `32 x 11` dataset `mtcars` where `rownames` correspond to the car model.

```{r}
data(mtcars)
mtcars <- mtcars %>% as_tibble(rownames = 'CAR')
```

Renaming column headers:

```{r}
mtcars %>% rename_with(toupper)
```

```{r}
mtcars %>% rename_with(function(x) paste0(x, "_1"), .cols = -1)
```

Alternatively with base R:

```{r, eval=FALSE}
names(mtcars)[-1] <- paste0(names(mtcars[-1]), '_1')
```



### Grouped operations

```{r}
mtcars %>% group_by(cyl) %>% summarise(avg_mpg = mean(mpg))
```

Multiple columns:

```{r}
mtcars %>% group_by(cyl) %>% 
  summarise(across(c(mpg, disp, hp), mean, .names = "mean_{col}"))
```

```{r}
mtcars %>% group_by(cyl) %>% 
  summarise(across(where(is.numeric), mean, .names = "mean_{col}"))
```

Alternatively, in base R:

```{r}
aggregate(mpg ~ cyl, data = mtcars, FUN = mean)
```



### Data transformation

Scalar transformation of numeric columns:

```{r}
mtcars %>% mutate(mpg = mpg*2)
```

Conditional transformation and keep the old columns:

```{r}
mtcars %>% 
  mutate(across(where(is.numeric), function(x) x*2, .names = "double_{col}"))
```

Mutate multiple columns and replace old columns:

```{r}
mtcars %>% mutate(across(c(mpg, disp), function(x) x*3))
```

Iterating across the columns using `purrr::modify` instead:

```{r}
mtcars %>% modify_if(is.numeric, ~ .x*3)
```


### Joining and separating character columns

For the `CAR` column comprised of strings, separate the individual strings into multiple columns:

```{r, warning=FALSE}
mtcars %>% separate(CAR, c('Brand', 'Model'), sep = " ", extra = 'merge')
```

Sumamry based on the car brand using the `%>%` pipe between `tidyverse` verbs:

```{r, warning=FALSE}
mtcars %>% separate(CAR, c('Brand', 'Model'), sep = " ", extra = 'merge') %>%
  group_by(Brand) %>% summarise(count = n(), mean_mpg = mean(mpg)) %>%
  arrange(desc(count))
```

Separation of columns by strings, using base R instead:

```{r, eval=FALSE}
mtcars$Brand <- unlist(
  lapply(strsplit(mtcars$CAR, split = ' '), function(x) x[1])
)
mtcars$Model <- unlist(
  lapply(strsplit(mtcars$CAR, split = ' '), function(x) x[2])
)
```

Combining columns into a new column:

```{r}
data(iris)
iris <- as_tibble(iris)
iris %>% unite('Petal.Dimensions', c(`Petal.Length`, `Petal.Width`),
               sep = " x ", remove = FALSE)
```

In base R:

```{r, eval=FALSE}
iris$Petal.Dimensions <- paste(iris$Petal.Length, iris$Petal.Width, sep = " x ")
```



### Filtering rows

Filtering rows based on strings:

```{r}
mtcars %>% filter(str_detect(CAR, 'Mazda'))
```

```{r}
mtcars %>% filter(str_detect(CAR, c('Mazda', 'Merc')))
```

Alternatively, using base R:

```{r, eval=FALSE}
mtcars[grepl('Mazda', mtcars$CAR),]
mtcars[grepl('Mazda|Merc', mtcars$CAR),]
```

Filtering rows based on a numeric column:

```{r}
mtcars %>% filter(between(mpg, 18, 20))
```

```{r}
mtcars %>% filter(cyl %in% c(6, 8))
```

Alternatively, in base R:

```{r, eval=FALSE}
mtcars[which(mtcars$mpg > 18 & mtcars$mpg < 20),]
mtcars[which(mtcars$cyl %in% c(6,8)),]
```



### Subsetting columns based on strings

Selecting columns based on column name matching:

```{r}
mtcars %>% select(contains('m'))
```

```{r}
mtcars %>% select(starts_with('m'))
```

Or using regex expressions:

```{r}
mtcars %>% select(matches('^m'))
```

Alternatively, in base R:

```{r, eval=FALSE}
mtcars[,grepl('m', names(mtcars))]
mtcars[,grepl('^m', names(mtcars))]
```



### Long and wide data formats

Transforming datasets into long/wide formats:

```{r}
mtcars_long <- mtcars %>% pivot_longer(-1, names_to = 'Metric', values_to = 'Values')
mtcars_long
```

```{r}
mtcars_wide <- mtcars_long %>% 
  pivot_wider(names_from = 'Metric', values_from = 'Values')
mtcars_wide
```



### Trimming strings

Trimming character columns, then re-encoding them as factors:

```{r}
iris %>% mutate(Species = strtrim(Species, 3)) %>%
  mutate(Species = factor(Species, levels = c('set', 'ver', 'vir')))
```



### Iterating over list of dataframes

Forming a list of dataframes by column value:

```{r}
mtcars_lst <- mtcars %>% group_split(cyl)
```

Looping over each element of the list and renaming columns:

```{r}
mtcars_lst <- lapply(mtcars_lst, function(x) 
  rename_with(x, function(y) paste0(y, "_", as.character(unique(x$cyl))), .cols = -1))
mtcars_lst[[1]]
```

Using `purrr::map` instead:

```{r, warning=FALSE}
mtcars_lst <- mtcars %>% group_split(cyl)
mtcars_lst <- mtcars_lst %>% 
  map(~ rename_with(.x, function(y) paste0(y, "_", as.character(unique(.x$cyl))), 
                    .cols = -1))
mtcars_lst[[1]]
```

Fitting a linear model for each element of the list, iteratively:

```{r}
mtcars_lst <- mtcars %>% group_split(cyl)
mtcars_lst %>% 
  map(~ lm(mpg ~ gear, data = .x)) %>%
  map(coef)
```

Using `broom` to clean up modelling result:

```{r, warning=FALSE}
library(broom)
mtcars_lst %>%
  map(~ lm(mpg ~ gear, data = .x)) %>%
  map(tidy) %>%
  bind_rows()
```

Using base R and the `apply` family instead:

```{r}
models <- lapply(mtcars_lst, function(x) lm(mpg ~ gear, data = x))
coefs <- lapply(models, coef)
coefs[[1]]
```



### Rowwise operations

Rowwise operations with `mutate`

```{r}
df <- tibble(name = c('Brian', 'Connor'),
             coffee = sample(1:10, 2),
             wine = sample(1:5, 2),
             juice = sample(1:5, 2))
df
```

```{r}
df %>% rowwise() %>% mutate(total = sum(c_across(coffee:juice)),
                            avg = mean(c_across(coffee:juice)))
```

```{r}
df %>% rowwise() %>% mutate(total = sum(c_across(coffee:juice))) %>%
  ungroup() %>%
  mutate(across(coffee:juice, function(x) x/total,
                .names = "{col}_prop."))
```



### Conditional transformation

Conditional `mutate` using `case_when`:

```{r}
mtcars %>% mutate(mileage_class = 
  case_when(mpg > 20 ~ 'High',
            mpg < 20 ~ 'Low')) %>%
  relocate(mileage_class, .after = mpg)
```

Conditional mutate using base R:

```{r}
mtcars$mileage_class <- ifelse(
  mtcars$mpg > 20, 'High', 'Low'
)
subset(mtcars, select = c(CAR, mpg, mileage_class, cyl:carb))
```



### Missing values

Handling missing values:
First, insert NAs randomly for the sake of this exercise:

```{r}
mtcars_NA <- map_df(mtcars, function(x) 
  {x[sample(c(TRUE, NA), prob = c(0.95, 0.01), size = length(x), replace = TRUE)]})
mtcars_NA
```

```{r}
dim(mtcars_NA)
```

Remove rows where any NA occurs:

```{r}
mtcars_NA %>% na.omit() %>% dim()
```

Identify columns with NAs and the number of ocurrences:

```{r}
vapply(mtcars_NA, function(x) sum(is.na(x)), double(1))
```

Remove columns with more than one missing value: 

```{r}
mtcars_NA %>% select(where(function(x) sum(is.na(x)) < 1)) %>% dim()
```

Replace missing values with zero using `tidyr::replace_na`: 

```{r}
mtcars_NA %>% map_dfc(~ replace_na(.x, 0))
```

Base R:

```{r, eval=FALSE}
mtcars_NA[is.na(mtcars_NA)] <- 0
```



### Joining dataframes

Mutating joins:

```{r}
df1 <- tibble(
  name = c('Brian', 'Connor', 'Jon'),
  city = c('Tokyo', 'London', 'Milan'),
  age = c(28, 25, 21)
)
df2 <- tibble(
  name = c('Brian', 'Connor'),
  hair = c('black', 'brown'),
  eyes = c('dark', 'hazel')
)
```

```{r}
df1 %>% inner_join(df2, by = 'name')
```

```{r}
df1 %>% left_join(df2, by = 'name')
```

Base R:

```{r, eval=FALSE}
merge(df1, df2, by = 'name')
merge(df1, df2, by = 'name', all.x = TRUE)
```


