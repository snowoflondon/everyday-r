[["index.html", "Everyday-R Chapter 1 Introduction 1.1 R syntax in this book 1.2 Code availability", " Everyday-R Brian Jungmin Park Chapter 1 Introduction This book serves as a collection of R Markdown files that aims to assist users in learning the practical syntax and usage of R. Mainly, code snippets and workflow aimed at tackling everyday tasks in data science will be covered, including data cleaning, data wrangling, iterations, machine learning with caret, data visualization, and web app design using Shiny. Each broad topic will be split into chapters, though there will be some overlap. 1.1 R syntax in this book Code chunks will be presented in a typical Markdown format as such, with the code output below: runif(n = 20, min = 0, max = 100) ## [1] 76.4369237 68.6105364 51.9171139 22.7441995 44.9952489 73.8980003 0.7298823 74.8694468 ## [9] 30.6383196 78.4543878 93.3116762 24.8269856 86.1226866 6.5530308 52.9560392 3.1868963 ## [17] 73.0393045 48.6647675 34.9391496 8.9322204 When using commands outside of base R, the loading of the parent package will be explicitly shown to avoid confusion: library(microbenchmark) microbenchmark::microbenchmark(runif(n = 20, min = 0, max = 100)) ## Unit: microseconds ## expr min lq mean median uq max neval ## runif(n = 20, min = 0, max = 100) 1.418 1.584 2.12319 1.668 1.834 7.709 100 Typically in longer chains of code, I will use %&gt;% from magrittr as a pipe. This is usually standard practice in code using packages from the tidyverse so it’s a good habit to start using it. Finally, here is the R version I am currently using: version ## _ ## platform x86_64-apple-darwin17.0 ## arch x86_64 ## os darwin17.0 ## system x86_64, darwin17.0 ## status ## major 4 ## minor 0.5 ## year 2021 ## month 03 ## day 31 ## svn rev 80133 ## language R ## version.string R version 4.0.5 (2021-03-31) ## nickname Shake and Throw 1.2 Code availability All code used to compile this book as well as the individual .Rmd files are available on my repository here "],["everyday-data-wrangling.html", "Chapter 2 Everyday data wrangling 2.1 Renaming column headers 2.2 Grouped operations 2.3 Data transformation 2.4 Joining and separating character columns 2.5 Filtering rows 2.6 Subsetting columns based on strings 2.7 Long and wide data formats 2.8 Trimming strings 2.9 Iterating over list of dataframes 2.10 Rowwise operations 2.11 Conditional transformation 2.12 Missing values 2.13 Joining dataframes", " Chapter 2 Everyday data wrangling Suppose there exists a test dataset and the user is tasked with proving their proficiency in exploratory data analysis (EDA). Alternatively, the user may be handed a piece of data (e.g., maybe an Excel sheet) and is asked to run some preliminary analysis. Prior to jumping straight into EDA and statistical modeling, the user must be able to transform the original data into a desirable format. This includes, but is not limited to, missing data imputation, scalar transformation, feature selection, group aggregation, and data filtering. The following notebook outlines the fundamentals of data wrangling, using practical base R and tidyverse solutions interchangeably. 2.1 Renaming column headers Suppose a 32 x 11 dataset mtcars where rownames correspond to the car model. data(mtcars) mtcars &lt;- mtcars %&gt;% as_tibble(rownames = &#39;CAR&#39;) Renaming column headers is straight forward with dplyr::rename: mtcars %&gt;% rename_with(toupper) ## # A tibble: 32 x 12 ## CAR MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows You can pass any function within rename_with() to alter the column headers: mtcars %&gt;% rename_with(function(x) paste0(x, &quot;_1&quot;), .cols = -1) ## # A tibble: 32 x 12 ## CAR mpg_1 cyl_1 disp_1 hp_1 drat_1 wt_1 qsec_1 vs_1 am_1 gear_1 carb_1 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Alternatively with base R, you can call the names attribute and alter that directly: names(mtcars)[-1] &lt;- paste0(names(mtcars[-1]), &#39;_1&#39;) 2.2 Grouped operations Grouped operations are most useful when you’re working with data where there is a categorical variable. Grouped summaries are powerful tools easily done with dplyr::summarise: mtcars %&gt;% group_by(cyl) %&gt;% summarise(avg_mpg = mean(mpg)) ## # A tibble: 3 x 2 ## cyl avg_mpg ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 Using multiple columns at once and renaming the output columns: mtcars %&gt;% group_by(cyl) %&gt;% summarise(across(c(mpg, disp, hp), mean, .names = &quot;mean_{col}&quot;)) ## # A tibble: 3 x 4 ## cyl mean_mpg mean_disp mean_hp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 105. 82.6 ## 2 6 19.7 183. 122. ## 3 8 15.1 353. 209. mtcars %&gt;% group_by(cyl) %&gt;% summarise(across(where(is.numeric), mean, .names = &quot;mean_{col}&quot;)) ## # A tibble: 3 x 11 ## cyl mean_mpg mean_disp mean_hp mean_drat mean_wt mean_qsec mean_vs mean_am mean_gear ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 105. 82.6 4.07 2.29 19.1 0.909 0.727 4.09 ## 2 6 19.7 183. 122. 3.59 3.12 18.0 0.571 0.429 3.86 ## 3 8 15.1 353. 209. 3.23 4.00 16.8 0 0.143 3.29 ## # … with 1 more variable: mean_carb &lt;dbl&gt; Alternatively, in base R, you can use aggregate() with the ~; you can read this as grouping mpg by cyl where by corresponds to the ~: aggregate(mpg ~ cyl, data = mtcars, FUN = mean) ## cyl mpg ## 1 4 26.66364 ## 2 6 19.74286 ## 3 8 15.10000 2.3 Data transformation Sometimes it’s useful to transform numeric columns: mtcars %&gt;% mutate(mpg = mpg*2) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 42 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 42 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 45.6 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 42.8 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 37.4 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 36.2 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 28.6 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 48.8 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 45.6 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 38.4 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Using across() allows for conditional transformation and keep the old columns, while renaming the new columns: mtcars %&gt;% mutate(across(where(is.numeric), function(x) x*2, .names = &quot;double_{col}&quot;)) ## # A tibble: 32 x 23 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb double_mpg ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 42 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 42 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 45.6 ## 4 Hornet 4 Dr… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 42.8 ## 5 Hornet Spor… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 37.4 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 36.2 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 28.6 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 48.8 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 45.6 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 38.4 ## # … with 22 more rows, and 10 more variables: double_cyl &lt;dbl&gt;, double_disp &lt;dbl&gt;, ## # double_hp &lt;dbl&gt;, double_drat &lt;dbl&gt;, double_wt &lt;dbl&gt;, double_qsec &lt;dbl&gt;, ## # double_vs &lt;dbl&gt;, double_am &lt;dbl&gt;, double_gear &lt;dbl&gt;, double_carb &lt;dbl&gt; You can overwrite the existing columns completely; also keep in mind that you can pass any function within across() as such: mtcars %&gt;% mutate(across(c(mpg, disp), function(x) x*3)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 63 6 480 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 63 6 480 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 68.4 4 324 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 64.2 6 774 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 56.1 8 1080 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 54.3 6 675 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 42.9 8 1080 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 73.2 4 440. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 68.4 4 422. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 57.6 6 503. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Iterating across the columns using purrr::modify instead: mtcars %&gt;% modify_if(is.numeric, ~ .x*3) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 63 18 480 330 11.7 7.86 49.4 0 3 12 12 ## 2 Mazda RX4 Wag 63 18 480 330 11.7 8.62 51.1 0 3 12 12 ## 3 Datsun 710 68.4 12 324 279 11.6 6.96 55.8 3 3 12 3 ## 4 Hornet 4 Drive 64.2 18 774 330 9.24 9.64 58.3 3 0 9 3 ## 5 Hornet Sportabout 56.1 24 1080 525 9.45 10.3 51.1 0 0 9 6 ## 6 Valiant 54.3 18 675 315 8.28 10.4 60.7 3 0 9 3 ## 7 Duster 360 42.9 24 1080 735 9.63 10.7 47.5 0 0 9 12 ## 8 Merc 240D 73.2 12 440. 186 11.1 9.57 60 3 0 12 6 ## 9 Merc 230 68.4 12 422. 285 11.8 9.45 68.7 3 0 12 6 ## 10 Merc 280 57.6 18 503. 369 11.8 10.3 54.9 3 0 12 12 ## # … with 22 more rows 2.4 Joining and separating character columns For the CAR column comprised of strings, you can separate the individual strings into multiple columns; the extra = 'merge' argument tells the function to separate the string based on the first instance of ” ” and merge the rest: mtcars %&gt;% separate(CAR, c(&#39;Brand&#39;, &#39;Model&#39;), sep = &quot; &quot;, extra = &#39;merge&#39;) ## # A tibble: 32 x 13 ## Brand Model mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant &lt;NA&gt; 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Combining multiple tidyverse verbs using the pipe %&gt;%: mtcars %&gt;% separate(CAR, c(&#39;Brand&#39;, &#39;Model&#39;), sep = &quot; &quot;, extra = &#39;merge&#39;) %&gt;% group_by(Brand) %&gt;% summarise(count = n(), mean_mpg = mean(mpg)) %&gt;% arrange(desc(count)) ## # A tibble: 22 x 3 ## Brand count mean_mpg ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Merc 7 19.0 ## 2 Fiat 2 29.8 ## 3 Hornet 2 20.0 ## 4 Mazda 2 21 ## 5 Toyota 2 27.7 ## 6 AMC 1 15.2 ## 7 Cadillac 1 10.4 ## 8 Camaro 1 13.3 ## 9 Chrysler 1 14.7 ## 10 Datsun 1 22.8 ## # … with 12 more rows Note that the pipe %&gt;% is part of the magrittr package but there’s no need to load it after loading tidyverse. The pipe notation is frequently used between tidyverse verbs but you can also use it in some base R operations as well. Separation of columns by strings, using base R instead involves using strsplit() which outputs a list and therefore we need to unpack it afterwards: mtcars$Brand &lt;- unlist( lapply(strsplit(mtcars$CAR, split = &#39; &#39;), function(x) x[1]) ) mtcars$Model &lt;- unlist( lapply(strsplit(mtcars$CAR, split = &#39; &#39;), function(x) x[2]) ) The opposite of separate() is unite() which combines columns into a single column: data(iris) iris &lt;- as_tibble(iris) iris %&gt;% unite(&#39;Petal.Dimensions&#39;, c(`Petal.Length`, `Petal.Width`), sep = &quot; x &quot;, remove = FALSE) ## # A tibble: 150 x 6 ## Sepal.Length Sepal.Width Petal.Dimensions Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 x 0.2 1.4 0.2 setosa ## 2 4.9 3 1.4 x 0.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 x 0.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 x 0.2 1.5 0.2 setosa ## 5 5 3.6 1.4 x 0.2 1.4 0.2 setosa ## 6 5.4 3.9 1.7 x 0.4 1.7 0.4 setosa ## 7 4.6 3.4 1.4 x 0.3 1.4 0.3 setosa ## 8 5 3.4 1.5 x 0.2 1.5 0.2 setosa ## 9 4.4 2.9 1.4 x 0.2 1.4 0.2 setosa ## 10 4.9 3.1 1.5 x 0.1 1.5 0.1 setosa ## # … with 140 more rows In base R, we create a new column using the $ notation: iris$Petal.Dimensions &lt;- paste(iris$Petal.Length, iris$Petal.Width, sep = &quot; x &quot;) 2.5 Filtering rows Typically, filtering involves a condition based on a column to select the corresponding rows. Here I am combining stringr::str_detect with dplyr::filter since the column I am filtering on is a character vector. mtcars %&gt;% filter(str_detect(CAR, &#39;Mazda&#39;)) ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 mtcars %&gt;% filter(str_detect(CAR, c(&#39;Mazda&#39;, &#39;Merc&#39;))) ## # A tibble: 5 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 4 Merc 450SE 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 5 Merc 450SLC 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 Ignoring upper/lower case distinction using regex(..., ignore_case = TRUE): mtcars %&gt;% filter(str_detect(CAR, regex(&#39;mazda&#39;, ignore_case = TRUE))) ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 Alternatively, using base R using grepl(): mtcars[grepl(&#39;Mazda&#39;, mtcars$CAR),] mtcars[grepl(&#39;Mazda|Merc&#39;, mtcars$CAR),] Using tolower() to make sure we’re on the same page in regards to case: mtcars[grepl(tolower(&#39;Mazda&#39;), tolower(mtcars$CAR)),] ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 Filtering rows based on a numeric column: mtcars %&gt;% filter(between(mpg, 18, 20)) ## # A tibble: 5 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 2 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 3 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 4 Pontiac Firebird 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 ## 5 Ferrari Dino 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 mtcars %&gt;% filter(cyl %in% c(6, 8)) ## # A tibble: 21 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 4 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 5 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 6 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 7 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 8 Merc 280C 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 9 Merc 450SE 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 10 Merc 450SL 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## # … with 11 more rows Alternatively, in base R, using which(): mtcars[which(mtcars$mpg &gt; 18 &amp; mtcars$mpg &lt; 20),] mtcars[which(mtcars$cyl %in% c(6,8)),] 2.6 Subsetting columns based on strings Subsetting columns typically involves using square brackets [ ] in base R, but can be done easily with dplyr::select; select() supports multiple helper functions such as starts_with(), ends_with(), and match(). mtcars %&gt;% select(contains(&#39;m&#39;)) ## # A tibble: 32 x 2 ## mpg am ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 1 ## 2 21 1 ## 3 22.8 1 ## 4 21.4 0 ## 5 18.7 0 ## 6 18.1 0 ## 7 14.3 0 ## 8 24.4 0 ## 9 22.8 0 ## 10 19.2 0 ## # … with 22 more rows mtcars %&gt;% select(starts_with(&#39;m&#39;), ends_with(&#39;c&#39;)) ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows Using regex, with the anchors ^ and $: mtcars %&gt;% select(matches(&#39;^m&#39;), matches(&#39;c$&#39;)) ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows Alternatively, in base R and regex: mtcars[,grepl(&#39;^m|c$&#39;, names(mtcars))] ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows 2.7 Long and wide data formats Transforming datasets into long/wide formats is a typical task in EDA, and this can be done using tidyr: mtcars_long &lt;- mtcars %&gt;% pivot_longer(-1, names_to = &#39;Metric&#39;, values_to = &#39;Values&#39;) mtcars_long ## # A tibble: 352 x 3 ## CAR Metric Values ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mazda RX4 mpg 21 ## 2 Mazda RX4 cyl 6 ## 3 Mazda RX4 disp 160 ## 4 Mazda RX4 hp 110 ## 5 Mazda RX4 drat 3.9 ## 6 Mazda RX4 wt 2.62 ## 7 Mazda RX4 qsec 16.5 ## 8 Mazda RX4 vs 0 ## 9 Mazda RX4 am 1 ## 10 Mazda RX4 gear 4 ## # … with 342 more rows Having the dataset in this long format allows us to create visualizations such as the boxplot much easier. Pivoting the long format back to a wide format as also straightforward with tidyr: mtcars_wide &lt;- mtcars_long %&gt;% pivot_wider(names_from = &#39;Metric&#39;, values_from = &#39;Values&#39;) mtcars_wide ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 Wag 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 Drive 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Sportabout 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows In base R, you can use reshape() with the argument direction = but I don’t find its syntax very intuitive. Alternatively, using data.table gets us the solution much easier: library(data.table) melt(setDT(mtcars), id.vars = c(&#39;CAR&#39;), variable.name = &#39;Metric&#39;) ## CAR Metric value ## 1: Mazda RX4 mpg 21.0 ## 2: Mazda RX4 Wag mpg 21.0 ## 3: Datsun 710 mpg 22.8 ## 4: Hornet 4 Drive mpg 21.4 ## 5: Hornet Sportabout mpg 18.7 ## --- ## 348: Lotus Europa carb 2.0 ## 349: Ford Pantera L carb 4.0 ## 350: Ferrari Dino carb 6.0 ## 351: Maserati Bora carb 8.0 ## 352: Volvo 142E carb 2.0 Note that using data.table returns a data.table object (due to the setDT() function), which differs from the tibble we’ve been using for packages within tidyverse. There are some advantages to using data.table instead, especially when working with very large datasets. For the sake of this book I will mostly use base R and tidyverse, other than exceptional cases. 2.8 Trimming strings Trimming character columns, then re-encoding them as factors: iris %&gt;% mutate(Species = strtrim(Species, 3)) %&gt;% mutate(Species = factor(Species, levels = c(&#39;set&#39;, &#39;ver&#39;, &#39;vir&#39;))) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 set ## 2 4.9 3 1.4 0.2 set ## 3 4.7 3.2 1.3 0.2 set ## 4 4.6 3.1 1.5 0.2 set ## 5 5 3.6 1.4 0.2 set ## 6 5.4 3.9 1.7 0.4 set ## 7 4.6 3.4 1.4 0.3 set ## 8 5 3.4 1.5 0.2 set ## 9 4.4 2.9 1.4 0.2 set ## 10 4.9 3.1 1.5 0.1 set ## # … with 140 more rows Sometimes when you’re importing datasets from external and/or untrustworthy sources (e.g., an Excel sheet) it’s worth checking for any whitespaces. In that case you can use stringr::str_trim to remove all whitespaces prior to data analysis. iris %&gt;% mutate(Species = str_trim(Species)) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows 2.9 Iterating over list of dataframes Analogously to base R’s split, using group_split() allows us to convert the dataset to a list based on a column; the length of this output list would correspond to the unique number of column entries: mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) Iteration will be covered in more detail in a future chapter, but using base R’s apply family is straightforward. In this case since we’re working with lists, we will use lapply() and pass a function (in this case, rename_with()): mtcars_lst &lt;- lapply(mtcars_lst, function(x) rename_with(x, function(y) paste0(y, &quot;_&quot;, as.character(unique(x$cyl))), .cols = -1)) mtcars_lst[[1]] ## # A tibble: 11 x 12 ## CAR mpg_4 cyl_4 disp_4 hp_4 drat_4 wt_4 qsec_4 vs_4 am_4 gear_4 carb_4 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 2 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 4 Fiat 128 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 5 Honda Civic 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 6 Toyota Corolla 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 7 Toyota Corona 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 Fiat X1-9 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 9 Porsche 914-2 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 10 Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 ## 11 Volvo 142E 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 A tidyverse alternative to apply is purrr::map and its variations: mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) mtcars_lst &lt;- mtcars_lst %&gt;% map(~ rename_with(.x, function(y) paste0(y, &quot;_&quot;, as.character(unique(.x$cyl))), .cols = -1)) mtcars_lst[[1]] ## # A tibble: 11 x 12 ## CAR mpg_4 cyl_4 disp_4 hp_4 drat_4 wt_4 qsec_4 vs_4 am_4 gear_4 carb_4 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 2 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 4 Fiat 128 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 5 Honda Civic 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 6 Toyota Corolla 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 7 Toyota Corona 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 Fiat X1-9 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 9 Porsche 914-2 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 10 Lotus Europa 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 ## 11 Volvo 142E 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 Fitting a linear model is easy using iterations; in this case we fit lm() on the variables mpg and gear to identify their relationship: mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(coef) ## [[1]] ## (Intercept) gear ## 15.08125 2.83125 ## ## [[2]] ## (Intercept) gear ## 19.82 -0.02 ## ## [[3]] ## (Intercept) gear ## 14.525 0.175 Using broom::tidy to clean up modelling result and output the model estimates: library(broom) mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(tidy) %&gt;% bind_rows() ## # A tibble: 6 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 15.1 10.8 1.39 0.197 ## 2 gear 2.83 2.62 1.08 0.308 ## 3 (Intercept) 19.8 3.68 5.38 0.00299 ## 4 gear -0.0200 0.942 -0.0212 0.984 ## 5 (Intercept) 14.5 3.41 4.25 0.00112 ## 6 gear 0.175 1.02 0.172 0.866 Using base R and the apply family instead: models &lt;- lapply(mtcars_lst, function(x) lm(mpg ~ gear, data = x)) coefs &lt;- lapply(models, coef) coefs[[1]] ## (Intercept) gear ## 15.08125 2.83125 2.10 Rowwise operations df &lt;- tibble(name = c(&#39;Brian&#39;, &#39;Connor&#39;), coffee = sample(1:10, 2), wine = sample(1:5, 2), juice = sample(1:5, 2)) df ## # A tibble: 2 x 4 ## name coffee wine juice ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Brian 9 1 3 ## 2 Connor 1 5 4 Sometimes it’s useful to run calculations in a row-wise fashion; for example using mutate() with the helper function c_across(): df %&gt;% rowwise() %&gt;% mutate(total = sum(c_across(coffee:juice)), avg = mean(c_across(coffee:juice))) ## # A tibble: 2 x 6 ## # Rowwise: ## name coffee wine juice total avg ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Brian 9 1 3 13 4.33 ## 2 Connor 1 5 4 10 3.33 Calculating the proportions using a combination of row-wise and column-wise operations with c_across() and across(): df %&gt;% rowwise() %&gt;% mutate(total = sum(c_across(coffee:juice))) %&gt;% ungroup() %&gt;% mutate(across(coffee:juice, function(x) x/total, .names = &quot;{col}_prop.&quot;)) ## # A tibble: 2 x 8 ## name coffee wine juice total coffee_prop. wine_prop. juice_prop. ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brian 9 1 3 13 0.692 0.0769 0.231 ## 2 Connor 1 5 4 10 0.1 0.5 0.4 2.11 Conditional transformation Conditional transformations are useful when creating categories based on a series of logical statements; this is done using case_when() to define the conditions: mtcars %&gt;% mutate(mileage_class = case_when(mpg &gt; 20 ~ &#39;High&#39;, mpg &lt; 20 ~ &#39;Low&#39;)) %&gt;% relocate(mileage_class, .after = mpg) ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am gear carb ## 1: Mazda RX4 21.0 High 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2: Mazda RX4 Wag 21.0 High 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3: Datsun 710 22.8 High 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4: Hornet 4 Drive 21.4 High 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5: Hornet Sportabout 18.7 Low 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6: Valiant 18.1 Low 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7: Duster 360 14.3 Low 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8: Merc 240D 24.4 High 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9: Merc 230 22.8 High 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10: Merc 280 19.2 Low 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 11: Merc 280C 17.8 Low 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 12: Merc 450SE 16.4 Low 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 13: Merc 450SL 17.3 Low 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 14: Merc 450SLC 15.2 Low 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 15: Cadillac Fleetwood 10.4 Low 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 16: Lincoln Continental 10.4 Low 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 17: Chrysler Imperial 14.7 Low 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 18: Fiat 128 32.4 High 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 19: Honda Civic 30.4 High 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 20: Toyota Corolla 33.9 High 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 21: Toyota Corona 21.5 High 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 22: Dodge Challenger 15.5 Low 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 23: AMC Javelin 15.2 Low 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 24: Camaro Z28 13.3 Low 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 25: Pontiac Firebird 19.2 Low 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 26: Fiat X1-9 27.3 High 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 27: Porsche 914-2 26.0 High 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 28: Lotus Europa 30.4 High 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 29: Ford Pantera L 15.8 Low 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 30: Ferrari Dino 19.7 Low 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 31: Maserati Bora 15.0 Low 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 32: Volvo 142E 21.4 High 4 121.0 109 4.11 2.780 18.60 1 1 4 2 ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am gear carb Conditional mutate using base R involves using ifelse(): mtcars$mileage_class &lt;- ifelse( mtcars$mpg &gt; 20, &#39;High&#39;, &#39;Low&#39; ) subset(mtcars, select = c(CAR, mpg, mileage_class, cyl:carb)) ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am gear carb ## 1: Mazda RX4 21.0 High 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2: Mazda RX4 Wag 21.0 High 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3: Datsun 710 22.8 High 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4: Hornet 4 Drive 21.4 High 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5: Hornet Sportabout 18.7 Low 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6: Valiant 18.1 Low 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7: Duster 360 14.3 Low 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8: Merc 240D 24.4 High 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9: Merc 230 22.8 High 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10: Merc 280 19.2 Low 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 11: Merc 280C 17.8 Low 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 12: Merc 450SE 16.4 Low 8 275.8 180 3.07 4.070 17.40 0 0 3 3 ## 13: Merc 450SL 17.3 Low 8 275.8 180 3.07 3.730 17.60 0 0 3 3 ## 14: Merc 450SLC 15.2 Low 8 275.8 180 3.07 3.780 18.00 0 0 3 3 ## 15: Cadillac Fleetwood 10.4 Low 8 472.0 205 2.93 5.250 17.98 0 0 3 4 ## 16: Lincoln Continental 10.4 Low 8 460.0 215 3.00 5.424 17.82 0 0 3 4 ## 17: Chrysler Imperial 14.7 Low 8 440.0 230 3.23 5.345 17.42 0 0 3 4 ## 18: Fiat 128 32.4 High 4 78.7 66 4.08 2.200 19.47 1 1 4 1 ## 19: Honda Civic 30.4 High 4 75.7 52 4.93 1.615 18.52 1 1 4 2 ## 20: Toyota Corolla 33.9 High 4 71.1 65 4.22 1.835 19.90 1 1 4 1 ## 21: Toyota Corona 21.5 High 4 120.1 97 3.70 2.465 20.01 1 0 3 1 ## 22: Dodge Challenger 15.5 Low 8 318.0 150 2.76 3.520 16.87 0 0 3 2 ## 23: AMC Javelin 15.2 Low 8 304.0 150 3.15 3.435 17.30 0 0 3 2 ## 24: Camaro Z28 13.3 Low 8 350.0 245 3.73 3.840 15.41 0 0 3 4 ## 25: Pontiac Firebird 19.2 Low 8 400.0 175 3.08 3.845 17.05 0 0 3 2 ## 26: Fiat X1-9 27.3 High 4 79.0 66 4.08 1.935 18.90 1 1 4 1 ## 27: Porsche 914-2 26.0 High 4 120.3 91 4.43 2.140 16.70 0 1 5 2 ## 28: Lotus Europa 30.4 High 4 95.1 113 3.77 1.513 16.90 1 1 5 2 ## 29: Ford Pantera L 15.8 Low 8 351.0 264 4.22 3.170 14.50 0 1 5 4 ## 30: Ferrari Dino 19.7 Low 6 145.0 175 3.62 2.770 15.50 0 1 5 6 ## 31: Maserati Bora 15.0 Low 8 301.0 335 3.54 3.570 14.60 0 1 5 8 ## 32: Volvo 142E 21.4 High 4 121.0 109 4.11 2.780 18.60 1 1 4 2 ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am gear carb 2.12 Missing values Handling missing values is tedious but often required when working with dodgy data. First, for the sake of our exercise we insert NAs randomly in the mtcars dataset: mtcars_NA &lt;- map_df(mtcars, function(x) {x[sample(c(TRUE, NA), prob = c(0.95, 0.01), size = length(x), replace = TRUE)]}) mtcars_NA ## # A tibble: 32 x 13 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb mileage_class ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 High ## 2 Mazda RX… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 High ## 3 Datsun 7… 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 High ## 4 Hornet 4… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 High ## 5 Hornet S… 18.7 NA 360 175 3.15 3.44 17.0 0 0 3 2 Low ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 Low ## 7 Duster 3… 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 Low ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 High ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 High ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 Low ## # … with 22 more rows Check the dimensions of this dataset to compare what happens when we remove NAs: dim(mtcars_NA) ## [1] 32 13 Remove rows where any NA occurs: mtcars_NA %&gt;% na.omit() %&gt;% dim() ## [1] 29 13 Identify columns with NAs and the number of occurrences: vapply(mtcars_NA, function(x) sum(is.na(x)), double(1)) ## CAR mpg cyl disp hp drat ## 0 0 2 0 0 0 ## wt qsec vs am gear carb ## 0 0 0 1 0 0 ## mileage_class ## 0 Remove columns with more than one missing value: mtcars_NA %&gt;% select(where(function(x) sum(is.na(x)) &lt; 1)) %&gt;% dim() ## [1] 32 11 Replace missing values with zero using tidyr::replace_na: mtcars_NA %&gt;% map_dfc(~ replace_na(.x, 0)) ## # A tibble: 32 x 13 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb mileage_class ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 High ## 2 Mazda RX… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 High ## 3 Datsun 7… 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 High ## 4 Hornet 4… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 High ## 5 Hornet S… 18.7 0 360 175 3.15 3.44 17.0 0 0 3 2 Low ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 Low ## 7 Duster 3… 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 Low ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 High ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 High ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 Low ## # … with 22 more rows Base R and using is.na() instead: mtcars_NA[is.na(mtcars_NA)] &lt;- 0 2.13 Joining dataframes Mutating joins in tidyverse are analogous to the inner and outer joins in SQL syntax: df1 &lt;- tibble( name = c(&#39;Brian&#39;, &#39;Connor&#39;, &#39;Jon&#39;), city = c(&#39;Tokyo&#39;, &#39;London&#39;, &#39;Milan&#39;), age = c(28, 25, 21) ) df2 &lt;- tibble( name = c(&#39;Brian&#39;, &#39;Connor&#39;), hair = c(&#39;black&#39;, &#39;brown&#39;), eyes = c(&#39;dark&#39;, &#39;hazel&#39;) ) df1 %&gt;% inner_join(df2, by = &#39;name&#39;) ## # A tibble: 2 x 5 ## name city age hair eyes ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel df1 %&gt;% left_join(df2, by = &#39;name&#39;) ## # A tibble: 3 x 5 ## name city age hair eyes ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel ## 3 Jon Milan 21 &lt;NA&gt; &lt;NA&gt; Base R uses merge() with the argument all.x = and all_y =: merge(df1, df2, by = &#39;name&#39;) ## name city age hair eyes ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel merge(df1, df2, by = &#39;name&#39;, all.x = TRUE) ## name city age hair eyes ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel ## 3 Jon Milan 21 &lt;NA&gt; &lt;NA&gt; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
