[["index.html", "Everyday-R Chapter 1 Introduction 1.1 R syntax in this book 1.2 R packages commonly used in this book 1.3 Installing R packages 1.4 Code availability", " Everyday-R Brian Jungmin Park Chapter 1 Introduction This book serves as a collection of R Markdown files that aims to assist users in learning the practical syntax and usage of R. Mainly, code snippets and workflow aimed at tackling everyday tasks in data science will be covered, including data cleaning, data wrangling, iterations, machine learning with caret, data visualization, and web app design using Shiny. Each broad topic will be split into chapters, though there will be some overlap. 1.1 R syntax in this book Code chunks will be presented in a typical Markdown format as such, with the code output below: runif(n = 20, min = 0, max = 100) ## [1] 31.1369736 49.0296688 62.6697859 27.5735012 46.4819165 91.7273047 ## [7] 61.8378274 62.8369478 20.1892243 60.8515537 41.1099596 26.5676537 ## [13] 58.2009699 82.2781483 27.6761240 1.4618563 70.4037433 54.5994329 ## [19] 0.3614902 15.1119134 When using commands outside of base R, the loading of the parent package will be explicitly shown to avoid confusion: library(microbenchmark) microbenchmark::microbenchmark(runif(n = 20, min = 0, max = 100)) ## Unit: microseconds ## expr min lq mean median uq max neval ## runif(n = 20, min = 0, max = 100) 1.293 1.501 1.67735 1.543 1.667 7.834 100 Typically in longer chains of code, I will use %&gt;% from magrittr as a pipe. This is usually standard practice in code using packages from the tidyverse so it’s a good habit to start using it. Finally, here is the R version I am currently using: version ## _ ## platform x86_64-apple-darwin17.0 ## arch x86_64 ## os darwin17.0 ## system x86_64, darwin17.0 ## status ## major 4 ## minor 0.5 ## year 2021 ## month 03 ## day 31 ## svn rev 80133 ## language R ## version.string R version 4.0.5 (2021-03-31) ## nickname Shake and Throw 1.2 R packages commonly used in this book tidyverse: a collection of packages for data science, including dplyr, purrr, stringr, forcats, readr, and ggplot. caret: package for implementation of machine learning models, with support for algorithms such as ranger, rpart, xgbTree, and svmLinear. broom: package for summarizing of model estimates. Shiny: package for implementation and designing of interactive web apps. 1.3 Installing R packages R packages found in this book are available on CRAN and thus can be installed simply by running install.packages(). For packages not on CRAN (or if you want to download developmental versions of a package), you can install packages straight from a GitHub repository by running devtools::install_github(). 1.4 Code availability All code used to compile this book as well as the individual .Rmd files are available on my repository here "],["everyday-data-wrangling.html", "Chapter 2 Everyday data wrangling 2.1 Renaming column headers 2.2 Grouped operations 2.3 Data transformation 2.4 Joining and separating character columns 2.5 Filtering rows 2.6 Subsetting columns based on strings 2.7 Long and wide data formats 2.8 Trimming strings 2.9 Iterating over list of dataframes 2.10 Rowwise operations 2.11 Conditional transformation 2.12 Missing values 2.13 Joining dataframes", " Chapter 2 Everyday data wrangling Suppose there exists a test dataset and the user is tasked with proving their proficiency in exploratory data analysis (EDA). Alternatively, the user may be handed a piece of data (e.g., maybe an Excel sheet) and is asked to run some preliminary analysis. Prior to jumping straight into EDA and statistical modeling, the user must be able to transform the original data into a desirable format. This includes, but is not limited to, missing data imputation, scalar transformation, feature selection, group aggregation, and data filtering. The following notebook outlines the fundamentals of data wrangling, using practical base R and tidyverse solutions interchangeably. library(tidyverse) 2.1 Renaming column headers Suppose a 32 x 11 dataset mtcars where rownames correspond to the car model. data(mtcars) mtcars &lt;- mtcars %&gt;% as_tibble(rownames = &#39;CAR&#39;) Renaming column headers with dplyr::rename is as simple as rename(new_name = old_name), but with rename_with() there’s more flexibility: mtcars %&gt;% rename_with(toupper) ## # A tibble: 32 x 12 ## CAR MPG CYL DISP HP DRAT WT QSEC VS AM GEAR CARB ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows You can pass any function within rename_with() to alter the column headers and use the .cols = argument to define which columns you’d apply the function to: mtcars %&gt;% rename_with(function(x) paste0(x, &quot;_1&quot;), .cols = -1) ## # A tibble: 32 x 12 ## CAR mpg_1 cyl_1 disp_1 hp_1 drat_1 wt_1 qsec_1 vs_1 am_1 gear_1 carb_1 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda… 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsu… 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Horne… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Horne… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valia… 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duste… 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc … 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc … 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc … 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Alternatively with base R, you can call the names attribute and alter that directly: names(mtcars)[-1] &lt;- paste0(names(mtcars[-1]), &#39;_1&#39;) 2.2 Grouped operations Grouped operations are most useful when you’re working with data where there is a categorical variable. Grouped summaries are powerful tools easily done with dplyr::summarise: mtcars %&gt;% group_by(cyl) %&gt;% summarise(avg_mpg = mean(mpg)) ## # A tibble: 3 x 2 ## cyl avg_mpg ## &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 ## 2 6 19.7 ## 3 8 15.1 Using multiple columns at once and renaming the output columns: mtcars %&gt;% group_by(cyl) %&gt;% summarise(across(c(mpg, disp, hp), mean, .names = &quot;mean_{col}&quot;)) ## # A tibble: 3 x 4 ## cyl mean_mpg mean_disp mean_hp ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 105. 82.6 ## 2 6 19.7 183. 122. ## 3 8 15.1 353. 209. mtcars %&gt;% group_by(cyl) %&gt;% summarise(across(where(is.numeric), mean, .names = &quot;mean_{col}&quot;)) ## # A tibble: 3 x 11 ## cyl mean_mpg mean_disp mean_hp mean_drat mean_wt mean_qsec mean_vs mean_am ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 4 26.7 105. 82.6 4.07 2.29 19.1 0.909 0.727 ## 2 6 19.7 183. 122. 3.59 3.12 18.0 0.571 0.429 ## 3 8 15.1 353. 209. 3.23 4.00 16.8 0 0.143 ## # … with 2 more variables: mean_gear &lt;dbl&gt;, mean_carb &lt;dbl&gt; Alternatively, in base R, you can use aggregate() with the ~; you can read this as grouping mpg by cyl where by corresponds to the ~: aggregate(mpg ~ cyl, data = mtcars, FUN = mean) ## cyl mpg ## 1 4 26.66364 ## 2 6 19.74286 ## 3 8 15.10000 When calculating the size of the groups, you can use n(): mtcars %&gt;% group_by(cyl) %&gt;% summarise(count = n()) ## # A tibble: 3 x 2 ## cyl count ## &lt;dbl&gt; &lt;int&gt; ## 1 4 11 ## 2 6 7 ## 3 8 14 Filtering by groups of size greater than a certain value: mtcars %&gt;% group_by(cyl) %&gt;% filter(n() &gt; 7) %&gt;% ungroup() ## # A tibble: 25 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 2 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 3 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 4 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 5 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 6 Merc 450SE 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 7 Merc 450SL 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## 8 Merc 450SLC 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 ## 9 Cadillac F… 10.4 8 472 205 2.93 5.25 18.0 0 0 3 4 ## 10 Lincoln Co… 10.4 8 460 215 3 5.42 17.8 0 0 3 4 ## # … with 15 more rows 2.3 Data transformation Sometimes it’s useful to transform numeric columns: mtcars %&gt;% mutate(mpg = mpg*2) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 42 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 42 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 45.6 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 42.8 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 37.4 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 36.2 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 28.6 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 48.8 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 45.6 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 38.4 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Using across() allows for conditional transformation and keep the old columns, while renaming the new columns: mtcars %&gt;% mutate(across(where(is.numeric), function(x) x*2, .names = &quot;double_{col}&quot;)) ## # A tibble: 32 x 23 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows, and 11 more variables: double_mpg &lt;dbl&gt;, ## # double_cyl &lt;dbl&gt;, double_disp &lt;dbl&gt;, double_hp &lt;dbl&gt;, double_drat &lt;dbl&gt;, ## # double_wt &lt;dbl&gt;, double_qsec &lt;dbl&gt;, double_vs &lt;dbl&gt;, double_am &lt;dbl&gt;, ## # double_gear &lt;dbl&gt;, double_carb &lt;dbl&gt; You can overwrite the existing columns completely; also keep in mind that you can pass any function within across() as such: mtcars %&gt;% mutate(across(c(mpg, disp), function(x) x*3)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 63 6 480 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 63 6 480 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 68.4 4 324 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 64.2 6 774 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 56.1 8 1080 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 54.3 6 675 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 42.9 8 1080 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 73.2 4 440. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 68.4 4 422. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 57.6 6 503. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Iterating across the columns using purrr::modify instead: mtcars %&gt;% modify_if(is.numeric, ~ .x*3) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 63 18 480 330 11.7 7.86 49.4 0 3 12 12 ## 2 Mazda RX4 … 63 18 480 330 11.7 8.62 51.1 0 3 12 12 ## 3 Datsun 710 68.4 12 324 279 11.6 6.96 55.8 3 3 12 3 ## 4 Hornet 4 D… 64.2 18 774 330 9.24 9.64 58.3 3 0 9 3 ## 5 Hornet Spo… 56.1 24 1080 525 9.45 10.3 51.1 0 0 9 6 ## 6 Valiant 54.3 18 675 315 8.28 10.4 60.7 3 0 9 3 ## 7 Duster 360 42.9 24 1080 735 9.63 10.7 47.5 0 0 9 12 ## 8 Merc 240D 73.2 12 440. 186 11.1 9.57 60 3 0 12 6 ## 9 Merc 230 68.4 12 422. 285 11.8 9.45 68.7 3 0 12 6 ## 10 Merc 280 57.6 18 503. 369 11.8 10.3 54.9 3 0 12 12 ## # … with 22 more rows Mutating columns of characters is also straightforward: mtcars %&gt;% mutate(CAR = gsub(&#39;Merc&#39;, &#39;Mercedes&#39;, CAR)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Mercedes 2… 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Mercedes 2… 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Mercedes 2… 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows mtcars %&gt;% mutate(CAR = gsub(&#39; &#39;, &#39;_&#39;, CAR)) %&gt;% mutate(across(CAR, tolower)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 mazda_rx4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 mazda_rx4_… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 datsun_710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 hornet_4_d… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 hornet_spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 duster_360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 merc_240d 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 merc_230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 merc_280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows 2.4 Joining and separating character columns For the CAR column comprised of strings, you can separate the individual strings into multiple columns; the extra = 'merge' argument tells the function to separate the string based on the first instance of ” ” and merge the rest: mtcars %&gt;% separate(CAR, c(&#39;Brand&#39;, &#39;Model&#39;), sep = &quot; &quot;, extra = &#39;merge&#39;) ## # A tibble: 32 x 13 ## Brand Model mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Dats… 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Horn… 4 Dr… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Horn… Spor… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Vali… &lt;NA&gt; 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Dust… 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Combining multiple tidyverse verbs using the pipe %&gt;%: mtcars %&gt;% separate(CAR, c(&#39;Brand&#39;, &#39;Model&#39;), sep = &quot; &quot;, extra = &#39;merge&#39;) %&gt;% group_by(Brand) %&gt;% summarise(count = n(), mean_mpg = mean(mpg)) %&gt;% arrange(desc(count)) ## # A tibble: 22 x 3 ## Brand count mean_mpg ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Merc 7 19.0 ## 2 Fiat 2 29.8 ## 3 Hornet 2 20.0 ## 4 Mazda 2 21 ## 5 Toyota 2 27.7 ## 6 AMC 1 15.2 ## 7 Cadillac 1 10.4 ## 8 Camaro 1 13.3 ## 9 Chrysler 1 14.7 ## 10 Datsun 1 22.8 ## # … with 12 more rows Note that the pipe %&gt;% is part of the magrittr package but there’s no need to load it after loading tidyverse. The pipe notation is frequently used between tidyverse verbs but you can also use it in some base R operations as well. Separation of columns by strings, using base R instead involves using strsplit() which outputs a list and therefore we need to unpack it afterwards: mtcars$Brand &lt;- unlist( lapply(strsplit(mtcars$CAR, split = &#39; &#39;), function(x) x[1]) ) mtcars$Model &lt;- unlist( lapply(strsplit(mtcars$CAR, split = &#39; &#39;), function(x) x[2]) ) The opposite of separate() is unite() which combines columns into a single column: data(iris) iris &lt;- as_tibble(iris) iris %&gt;% unite(&#39;Petal.Dimensions&#39;, c(`Petal.Length`, `Petal.Width`), sep = &quot; x &quot;, remove = FALSE) ## # A tibble: 150 x 6 ## Sepal.Length Sepal.Width Petal.Dimensions Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 x 0.2 1.4 0.2 setosa ## 2 4.9 3 1.4 x 0.2 1.4 0.2 setosa ## 3 4.7 3.2 1.3 x 0.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 x 0.2 1.5 0.2 setosa ## 5 5 3.6 1.4 x 0.2 1.4 0.2 setosa ## 6 5.4 3.9 1.7 x 0.4 1.7 0.4 setosa ## 7 4.6 3.4 1.4 x 0.3 1.4 0.3 setosa ## 8 5 3.4 1.5 x 0.2 1.5 0.2 setosa ## 9 4.4 2.9 1.4 x 0.2 1.4 0.2 setosa ## 10 4.9 3.1 1.5 x 0.1 1.5 0.1 setosa ## # … with 140 more rows In base R, we create a new column using the $ notation: iris$Petal.Dimensions &lt;- paste(iris$Petal.Length, iris$Petal.Width, sep = &quot; x &quot;) 2.5 Filtering rows Typically, filtering involves a condition based on a column to select the corresponding rows. Here I am combining stringr::str_detect with dplyr::filter since the column I am filtering on is a character vector. mtcars %&gt;% filter(str_detect(CAR, &#39;Mazda&#39;)) ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 mtcars %&gt;% filter(str_detect(CAR, c(&#39;Mazda&#39;, &#39;Merc&#39;))) ## # A tibble: 5 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 4 Merc 450SE 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 5 Merc 450SLC 15.2 8 276. 180 3.07 3.78 18 0 0 3 3 Ignoring upper/lower case distinction using regex(..., ignore_case = TRUE): mtcars %&gt;% filter(str_detect(CAR, regex(&#39;mazda&#39;, ignore_case = TRUE))) ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 Alternatively, using base R using grepl(): mtcars[grepl(&#39;Mazda&#39;, mtcars$CAR),] mtcars[grepl(&#39;Mazda|Merc&#39;, mtcars$CAR),] Using tolower() to make sure we’re on the same page in regards to case: mtcars[grepl(tolower(&#39;Mazda&#39;), tolower(mtcars$CAR)),] ## # A tibble: 2 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 4 4 Filtering rows based on a numeric column: mtcars %&gt;% filter(between(mpg, 18, 20)) ## # A tibble: 5 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Hornet Spor… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 2 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 3 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 4 Pontiac Fir… 19.2 8 400 175 3.08 3.84 17.0 0 0 3 2 ## 5 Ferrari Dino 19.7 6 145 175 3.62 2.77 15.5 0 1 5 6 mtcars %&gt;% filter(cyl %in% c(6, 8)) ## # A tibble: 21 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 4 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 5 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 6 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 7 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## 8 Merc 280C 17.8 6 168. 123 3.92 3.44 18.9 1 0 4 4 ## 9 Merc 450SE 16.4 8 276. 180 3.07 4.07 17.4 0 0 3 3 ## 10 Merc 450SL 17.3 8 276. 180 3.07 3.73 17.6 0 0 3 3 ## # … with 11 more rows Alternatively, in base R, using which(): mtcars[which(mtcars$mpg &gt; 18 &amp; mtcars$mpg &lt; 20),] mtcars[which(mtcars$cyl %in% c(6,8)),] 2.6 Subsetting columns based on strings Subsetting columns typically involves using square brackets [ ] in base R, but can be done easily with dplyr::select; select() supports multiple helper functions such as starts_with(), ends_with(), and match(). mtcars %&gt;% select(contains(&#39;m&#39;)) ## # A tibble: 32 x 2 ## mpg am ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 1 ## 2 21 1 ## 3 22.8 1 ## 4 21.4 0 ## 5 18.7 0 ## 6 18.1 0 ## 7 14.3 0 ## 8 24.4 0 ## 9 22.8 0 ## 10 19.2 0 ## # … with 22 more rows You can use multiple helper functions at once: mtcars %&gt;% select(starts_with(&#39;m&#39;), ends_with(&#39;c&#39;)) ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows Using regex, with the anchors ^ and $: mtcars %&gt;% select(matches(&#39;^m&#39;), matches(&#39;c$&#39;)) ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows Alternatively, in base R and regex: mtcars[,grepl(&#39;^m|c$&#39;, names(mtcars))] ## # A tibble: 32 x 2 ## mpg qsec ## &lt;dbl&gt; &lt;dbl&gt; ## 1 21 16.5 ## 2 21 17.0 ## 3 22.8 18.6 ## 4 21.4 19.4 ## 5 18.7 17.0 ## 6 18.1 20.2 ## 7 14.3 15.8 ## 8 24.4 20 ## 9 22.8 22.9 ## 10 19.2 18.3 ## # … with 22 more rows 2.7 Long and wide data formats Transforming datasets into long/wide formats is a typical task in EDA, and this can be done using tidyr: mtcars_long &lt;- mtcars %&gt;% pivot_longer(-1, names_to = &#39;Metric&#39;, values_to = &#39;Values&#39;) mtcars_long ## # A tibble: 352 x 3 ## CAR Metric Values ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; ## 1 Mazda RX4 mpg 21 ## 2 Mazda RX4 cyl 6 ## 3 Mazda RX4 disp 160 ## 4 Mazda RX4 hp 110 ## 5 Mazda RX4 drat 3.9 ## 6 Mazda RX4 wt 2.62 ## 7 Mazda RX4 qsec 16.5 ## 8 Mazda RX4 vs 0 ## 9 Mazda RX4 am 1 ## 10 Mazda RX4 gear 4 ## # … with 342 more rows Having the dataset in this long format allows us to create visualizations such as the boxplot much easier. Pivoting the long format back to a wide format as also straightforward with tidyr: mtcars_wide &lt;- mtcars_long %&gt;% pivot_wider(names_from = &#39;Metric&#39;, values_from = &#39;Values&#39;) mtcars_wide ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows In base R, you can use reshape() with the argument direction = but I don’t find its syntax very intuitive. Alternatively, using data.table gets us the solution much easier: library(data.table) melt(setDT(mtcars), id.vars = c(&#39;CAR&#39;), variable.name = &#39;Metric&#39;) ## CAR Metric value ## 1: Mazda RX4 mpg 21.0 ## 2: Mazda RX4 Wag mpg 21.0 ## 3: Datsun 710 mpg 22.8 ## 4: Hornet 4 Drive mpg 21.4 ## 5: Hornet Sportabout mpg 18.7 ## --- ## 348: Lotus Europa carb 2.0 ## 349: Ford Pantera L carb 4.0 ## 350: Ferrari Dino carb 6.0 ## 351: Maserati Bora carb 8.0 ## 352: Volvo 142E carb 2.0 Note that using data.table returns a data.table object (due to the setDT() function), which differs from the tibble we’ve been using for packages within tidyverse. There are some advantages to using data.table instead, especially when working with very large datasets. For the sake of this book I will mostly use base R and tidyverse, other than exceptional cases. 2.8 Trimming strings Trimming character columns, then re-encoding them as factors: iris %&gt;% mutate(Species = strtrim(Species, 3)) %&gt;% mutate(Species = factor(Species, levels = c(&#39;set&#39;, &#39;ver&#39;, &#39;vir&#39;))) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;fct&gt; ## 1 5.1 3.5 1.4 0.2 set ## 2 4.9 3 1.4 0.2 set ## 3 4.7 3.2 1.3 0.2 set ## 4 4.6 3.1 1.5 0.2 set ## 5 5 3.6 1.4 0.2 set ## 6 5.4 3.9 1.7 0.4 set ## 7 4.6 3.4 1.4 0.3 set ## 8 5 3.4 1.5 0.2 set ## 9 4.4 2.9 1.4 0.2 set ## 10 4.9 3.1 1.5 0.1 set ## # … with 140 more rows Sometimes when you’re importing datasets from external and/or untrustworthy sources (e.g., an Excel sheet) it’s worth checking for any whitespaces. In that case you can use stringr::str_trim to remove all whitespaces prior to data analysis. iris %&gt;% mutate(Species = str_trim(Species)) ## # A tibble: 150 x 5 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa ## 7 4.6 3.4 1.4 0.3 setosa ## 8 5 3.4 1.5 0.2 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 10 4.9 3.1 1.5 0.1 setosa ## # … with 140 more rows 2.9 Iterating over list of dataframes Analogously to base R’s split, using group_split() allows us to convert the dataset to a list based on a column; the length of this output list would correspond to the unique number of column entries: mtcars &lt;- as_tibble(mtcars) mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) Iteration will be covered in more detail in a future chapter, but using base R’s apply family is straightforward. In this case since we’re working with lists, we will use lapply() and pass a function (in this case, rename_with()): mtcars_lst &lt;- lapply(mtcars_lst, function(x) rename_with(x, function(y) paste0(y, &quot;_&quot;, as.character(unique(x$cyl))), .cols = -1)) mtcars_lst[[1]] ## # A tibble: 11 x 12 ## CAR mpg_4 cyl_4 disp_4 hp_4 drat_4 wt_4 qsec_4 vs_4 am_4 gear_4 carb_4 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Datsu… 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 2 Merc … 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc … 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 4 Fiat … 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 5 Honda… 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 6 Toyot… 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 7 Toyot… 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 Fiat … 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 9 Porsc… 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 10 Lotus… 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 ## 11 Volvo… 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 A tidyverse alternative to apply is purrr::map and its variations: mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) mtcars_lst &lt;- mtcars_lst %&gt;% map(~ rename_with(.x, function(y) paste0(y, &quot;_&quot;, as.character(unique(.x$cyl))), .cols = -1)) mtcars_lst[[1]] ## # A tibble: 11 x 12 ## CAR mpg_4 cyl_4 disp_4 hp_4 drat_4 wt_4 qsec_4 vs_4 am_4 gear_4 carb_4 ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Datsu… 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 2 Merc … 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 3 Merc … 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 4 Fiat … 32.4 4 78.7 66 4.08 2.2 19.5 1 1 4 1 ## 5 Honda… 30.4 4 75.7 52 4.93 1.62 18.5 1 1 4 2 ## 6 Toyot… 33.9 4 71.1 65 4.22 1.84 19.9 1 1 4 1 ## 7 Toyot… 21.5 4 120. 97 3.7 2.46 20.0 1 0 3 1 ## 8 Fiat … 27.3 4 79 66 4.08 1.94 18.9 1 1 4 1 ## 9 Porsc… 26 4 120. 91 4.43 2.14 16.7 0 1 5 2 ## 10 Lotus… 30.4 4 95.1 113 3.77 1.51 16.9 1 1 5 2 ## 11 Volvo… 21.4 4 121 109 4.11 2.78 18.6 1 1 4 2 Fitting a linear model is easy using iterations; in this case we fit lm() on the variables mpg and gear to identify their relationship: mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(coef) ## [[1]] ## (Intercept) gear ## 15.08125 2.83125 ## ## [[2]] ## (Intercept) gear ## 19.82 -0.02 ## ## [[3]] ## (Intercept) gear ## 14.525 0.175 Using broom::tidy to clean up modelling result and output the model estimates: library(broom) mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(tidy) %&gt;% bind_rows() ## # A tibble: 6 x 5 ## term estimate std.error statistic p.value ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 (Intercept) 15.1 10.8 1.39 0.197 ## 2 gear 2.83 2.62 1.08 0.308 ## 3 (Intercept) 19.8 3.68 5.38 0.00299 ## 4 gear -0.0200 0.942 -0.0212 0.984 ## 5 (Intercept) 14.5 3.41 4.25 0.00112 ## 6 gear 0.175 1.02 0.172 0.866 Using base R and the apply family instead: models &lt;- lapply(mtcars_lst, function(x) lm(mpg ~ gear, data = x)) coefs &lt;- lapply(models, coef) coefs[[1]] ## (Intercept) gear ## 15.08125 2.83125 2.10 Rowwise operations df &lt;- tibble(name = c(&#39;Brian&#39;, &#39;Connor&#39;), coffee = sample(1:10, 2), wine = sample(1:5, 2), juice = sample(1:5, 2)) df ## # A tibble: 2 x 4 ## name coffee wine juice ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; ## 1 Brian 10 1 2 ## 2 Connor 2 3 3 Sometimes it’s useful to run calculations in a row-wise fashion; for example using mutate() with the helper function c_across(): df %&gt;% rowwise() %&gt;% mutate(total = sum(c_across(coffee:juice)), avg = mean(c_across(coffee:juice))) ## # A tibble: 2 x 6 ## # Rowwise: ## name coffee wine juice total avg ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; ## 1 Brian 10 1 2 13 4.33 ## 2 Connor 2 3 3 8 2.67 Calculating the proportions using a combination of row-wise and column-wise operations with c_across() and across(): df %&gt;% rowwise() %&gt;% mutate(total = sum(c_across(coffee:juice))) %&gt;% ungroup() %&gt;% mutate(across(coffee:juice, function(x) x/total, .names = &quot;{col}_prop.&quot;)) ## # A tibble: 2 x 8 ## name coffee wine juice total coffee_prop. wine_prop. juice_prop. ## &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Brian 10 1 2 13 0.769 0.0769 0.154 ## 2 Connor 2 3 3 8 0.25 0.375 0.375 2.11 Conditional transformation Conditional transformations are useful when creating categories based on a series of logical statements; this is done using case_when() to define the conditions: mtcars %&gt;% mutate(mileage_class = case_when(mpg &gt; 20 ~ &#39;High&#39;, mpg &lt; 20 ~ &#39;Low&#39;)) %&gt;% relocate(mileage_class, .after = mpg) ## # A tibble: 32 x 13 ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 High 6 160 110 3.9 2.62 16.5 0 1 ## 2 Mazda RX… 21 High 6 160 110 3.9 2.88 17.0 0 1 ## 3 Datsun 7… 22.8 High 4 108 93 3.85 2.32 18.6 1 1 ## 4 Hornet 4… 21.4 High 6 258 110 3.08 3.22 19.4 1 0 ## 5 Hornet S… 18.7 Low 8 360 175 3.15 3.44 17.0 0 0 ## 6 Valiant 18.1 Low 6 225 105 2.76 3.46 20.2 1 0 ## 7 Duster 3… 14.3 Low 8 360 245 3.21 3.57 15.8 0 0 ## 8 Merc 240D 24.4 High 4 147. 62 3.69 3.19 20 1 0 ## 9 Merc 230 22.8 High 4 141. 95 3.92 3.15 22.9 1 0 ## 10 Merc 280 19.2 Low 6 168. 123 3.92 3.44 18.3 1 0 ## # … with 22 more rows, and 2 more variables: gear &lt;dbl&gt;, carb &lt;dbl&gt; In cases where we’re working with character columns, it’s useful to use grepl to match specific strings. After all, formula within case_when() needs to evaluate to a boolean on the left-hand side (e.g., mpg &gt; 20). Additionally, in cases where the condition is not specified or met, you can use TRUE ~ within case_when() as such: mtcars %&gt;% mutate(CAR = case_when(grepl(&#39;Merc&#39;, CAR) ~ toupper(CAR), TRUE ~ CAR)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 MERC 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 MERC 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 MERC 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows Conditional mutate using base R involves using ifelse(): mtcars$mileage_class &lt;- ifelse( mtcars$mpg &gt; 20, &#39;High&#39;, &#39;Low&#39; ) subset(mtcars, select = c(CAR, mpg, mileage_class, cyl:carb)) ## # A tibble: 32 x 13 ## CAR mpg mileage_class cyl disp hp drat wt qsec vs am ## &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 High 6 160 110 3.9 2.62 16.5 0 1 ## 2 Mazda RX… 21 High 6 160 110 3.9 2.88 17.0 0 1 ## 3 Datsun 7… 22.8 High 4 108 93 3.85 2.32 18.6 1 1 ## 4 Hornet 4… 21.4 High 6 258 110 3.08 3.22 19.4 1 0 ## 5 Hornet S… 18.7 Low 8 360 175 3.15 3.44 17.0 0 0 ## 6 Valiant 18.1 Low 6 225 105 2.76 3.46 20.2 1 0 ## 7 Duster 3… 14.3 Low 8 360 245 3.21 3.57 15.8 0 0 ## 8 Merc 240D 24.4 High 4 147. 62 3.69 3.19 20 1 0 ## 9 Merc 230 22.8 High 4 141. 95 3.92 3.15 22.9 1 0 ## 10 Merc 280 19.2 Low 6 168. 123 3.92 3.44 18.3 1 0 ## # … with 22 more rows, and 2 more variables: gear &lt;dbl&gt;, carb &lt;dbl&gt; 2.12 Missing values Handling missing values is tedious but often required when working with dodgy data. First, for the sake of our exercise we insert NAs randomly in the mtcars dataset: mtcars_NA &lt;- map_df(mtcars, function(x) {x[sample(c(TRUE, NA), prob = c(0.95, 0.01), size = length(x), replace = TRUE)]}) mtcars_NA ## # A tibble: 32 x 13 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows, and 1 more variable: mileage_class &lt;chr&gt; Remove rows where any NA occurs: mtcars_NA %&gt;% na.omit() ## # A tibble: 29 x 13 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 19 more rows, and 1 more variable: mileage_class &lt;chr&gt; Identify columns with NAs and the number of occurrences: vapply(mtcars_NA, function(x) sum(is.na(x)), double(1)) ## CAR mpg cyl disp hp ## 0 0 0 1 0 ## drat wt qsec vs am ## 0 0 1 1 0 ## gear carb mileage_class ## 0 0 0 Remove columns with more than one missing value: mtcars_NA %&gt;% select(where(function(x) sum(is.na(x)) &lt; 1)) ## # A tibble: 32 x 10 ## CAR mpg cyl hp drat wt am gear carb mileage_class ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; ## 1 Mazda RX4 21 6 110 3.9 2.62 1 4 4 High ## 2 Mazda RX4 Wag 21 6 110 3.9 2.88 1 4 4 High ## 3 Datsun 710 22.8 4 93 3.85 2.32 1 4 1 High ## 4 Hornet 4 Drive 21.4 6 110 3.08 3.22 0 3 1 High ## 5 Hornet Sportab… 18.7 8 175 3.15 3.44 0 3 2 Low ## 6 Valiant 18.1 6 105 2.76 3.46 0 3 1 Low ## 7 Duster 360 14.3 8 245 3.21 3.57 0 3 4 Low ## 8 Merc 240D 24.4 4 62 3.69 3.19 0 4 2 High ## 9 Merc 230 22.8 4 95 3.92 3.15 0 4 2 High ## 10 Merc 280 19.2 6 123 3.92 3.44 0 4 4 Low ## # … with 22 more rows Replace missing values with zero using tidyr::replace_na: mtcars_NA %&gt;% map_dfc(~ replace_na(.x, 0)) ## # A tibble: 32 x 13 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 4 4 ## 2 Mazda RX4 … 21 6 160 110 3.9 2.88 17.0 0 1 4 4 ## 3 Datsun 710 22.8 4 108 93 3.85 2.32 18.6 1 1 4 1 ## 4 Hornet 4 D… 21.4 6 258 110 3.08 3.22 19.4 1 0 3 1 ## 5 Hornet Spo… 18.7 8 360 175 3.15 3.44 17.0 0 0 3 2 ## 6 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 3 1 ## 7 Duster 360 14.3 8 360 245 3.21 3.57 15.8 0 0 3 4 ## 8 Merc 240D 24.4 4 147. 62 3.69 3.19 20 1 0 4 2 ## 9 Merc 230 22.8 4 141. 95 3.92 3.15 22.9 1 0 4 2 ## 10 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 4 4 ## # … with 22 more rows, and 1 more variable: mileage_class &lt;chr&gt; Base R and using is.na() instead: mtcars_NA[is.na(mtcars_NA)] &lt;- 0 2.13 Joining dataframes Mutating joins in tidyverse are analogous to the inner and outer joins in SQL syntax: df1 &lt;- tibble( name = c(&#39;Brian&#39;, &#39;Connor&#39;, &#39;Jon&#39;), city = c(&#39;Tokyo&#39;, &#39;London&#39;, &#39;Milan&#39;), age = c(28, 25, 21) ) df2 &lt;- tibble( name = c(&#39;Brian&#39;, &#39;Connor&#39;), hair = c(&#39;black&#39;, &#39;brown&#39;), eyes = c(&#39;dark&#39;, &#39;hazel&#39;) ) df1 %&gt;% inner_join(df2, by = &#39;name&#39;) ## # A tibble: 2 x 5 ## name city age hair eyes ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel df1 %&gt;% left_join(df2, by = &#39;name&#39;) ## # A tibble: 3 x 5 ## name city age hair eyes ## &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel ## 3 Jon Milan 21 &lt;NA&gt; &lt;NA&gt; Base R uses merge() with the argument all.x = and all_y =: merge(df1, df2, by = &#39;name&#39;) ## name city age hair eyes ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel merge(df1, df2, by = &#39;name&#39;, all.x = TRUE) ## name city age hair eyes ## 1 Brian Tokyo 28 black dark ## 2 Connor London 25 brown hazel ## 3 Jon Milan 21 &lt;NA&gt; &lt;NA&gt; "],["everyday-iterations.html", "Chapter 3 Everyday iterations 3.1 Iterating over multiple columns using apply, dplyr, and purrr 3.2 Iterating over lists 3.3 Iterating over vectors 3.4 Iterating with two inputs 3.5 Iterating over indices and names 3.6 Handling errors within purrr", " Chapter 3 Everyday iterations In the previous chapter, I briefly covered writing an iterative function using purrr::map. In an everyday practical setting, iterations are the most useful when we’ve split our dataset based on some sort of a variable of interest. For example, say we have a dataset containing patient outcome after a treatment with a therapeutic. We could split the data based on the type of the therapeutic and iterate a model to compare and contrast treatment effects. On the other hand, we could simply want to apply some sort of a function over multiple columns of a dataset to save the trouble of writing the same function over and over. A traditional iterative function involves explicitly writing a for loop. Though for loops are often misconstrued as being slower than the functional counterparts (e.g., the apply family of functions), the real down-side of for loops, as Hadley argues in his book, ‘Advanced R’, is that for loops do a poor job in conveying what should be done with the results. library(tidyverse) 3.1 Iterating over multiple columns using apply, dplyr, and purrr Returning to the familiar dataset mtcars, composed of 32 rows and 12 columns: data(mtcars) mtcars &lt;- as_tibble(mtcars, rownames = &#39;CAR&#39;) The basic apply function needs to know whether you’re iterating over columns or over rows using the MARGIN = argument: apply(mtcars[-1], MARGIN = 2, function(x) x/2) %&gt;% head() ## mpg cyl disp hp drat wt qsec vs am gear carb ## [1,] 10.50 3 80.0 55.0 1.950 1.3100 8.230 0.0 0.5 2.0 2.0 ## [2,] 10.50 3 80.0 55.0 1.950 1.4375 8.510 0.0 0.5 2.0 2.0 ## [3,] 11.40 2 54.0 46.5 1.925 1.1600 9.305 0.5 0.5 2.0 0.5 ## [4,] 10.70 3 129.0 55.0 1.540 1.6075 9.720 0.5 0.0 1.5 0.5 ## [5,] 9.35 4 180.0 87.5 1.575 1.7200 8.510 0.0 0.0 1.5 1.0 ## [6,] 9.05 3 112.5 52.5 1.380 1.7300 10.110 0.5 0.0 1.5 0.5 This returns a matrix, as apply is typically used for an array or a matrix. The one downside with apply is that the user cannot define what form the output will be in. The side effect of this is that I’ve had to exclude the first column because it contains characters. Running cbind afterwards to concatenate mtcars[1,] can do the job, though it’s cumbersome. Therefore, it’s often not advisable to run apply on a dataframe or a tibble. A better method is the dplyr::mutate solution: mtcars %&gt;% mutate(across(where(is.numeric), ~ .x/2)) ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 10.5 3 80 55 1.95 1.31 8.23 0 0.5 2 2 ## 2 Mazda RX4 … 10.5 3 80 55 1.95 1.44 8.51 0 0.5 2 2 ## 3 Datsun 710 11.4 2 54 46.5 1.92 1.16 9.30 0.5 0.5 2 0.5 ## 4 Hornet 4 D… 10.7 3 129 55 1.54 1.61 9.72 0.5 0 1.5 0.5 ## 5 Hornet Spo… 9.35 4 180 87.5 1.58 1.72 8.51 0 0 1.5 1 ## 6 Valiant 9.05 3 112. 52.5 1.38 1.73 10.1 0.5 0 1.5 0.5 ## 7 Duster 360 7.15 4 180 122. 1.60 1.78 7.92 0 0 1.5 2 ## 8 Merc 240D 12.2 2 73.4 31 1.84 1.60 10 0.5 0 2 1 ## 9 Merc 230 11.4 2 70.4 47.5 1.96 1.58 11.4 0.5 0 2 1 ## 10 Merc 280 9.6 3 83.8 61.5 1.96 1.72 9.15 0.5 0 2 2 ## # … with 22 more rows Note that instead of writing out function(x) x/2 I’m using the ~ .x notation which is often used in context of purrr:map. Either works. The purrr:map solution to this is: mtcars %&gt;% map_if(is.numeric, ~ .x/2) %&gt;% as_tibble() ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 10.5 3 80 55 1.95 1.31 8.23 0 0.5 2 2 ## 2 Mazda RX4 … 10.5 3 80 55 1.95 1.44 8.51 0 0.5 2 2 ## 3 Datsun 710 11.4 2 54 46.5 1.92 1.16 9.30 0.5 0.5 2 0.5 ## 4 Hornet 4 D… 10.7 3 129 55 1.54 1.61 9.72 0.5 0 1.5 0.5 ## 5 Hornet Spo… 9.35 4 180 87.5 1.58 1.72 8.51 0 0 1.5 1 ## 6 Valiant 9.05 3 112. 52.5 1.38 1.73 10.1 0.5 0 1.5 0.5 ## 7 Duster 360 7.15 4 180 122. 1.60 1.78 7.92 0 0 1.5 2 ## 8 Merc 240D 12.2 2 73.4 31 1.84 1.60 10 0.5 0 2 1 ## 9 Merc 230 11.4 2 70.4 47.5 1.96 1.58 11.4 0.5 0 2 1 ## 10 Merc 280 9.6 3 83.8 61.5 1.96 1.72 9.15 0.5 0 2 2 ## # … with 22 more rows Writing a for loop for something like this would be less optimal: mtcars2 &lt;- mtcars for (i in 2:ncol(mtcars2)){ mtcars2[,i] &lt;- mtcars2[,i]/2 } mtcars2 ## # A tibble: 32 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 10.5 3 80 55 1.95 1.31 8.23 0 0.5 2 2 ## 2 Mazda RX4 … 10.5 3 80 55 1.95 1.44 8.51 0 0.5 2 2 ## 3 Datsun 710 11.4 2 54 46.5 1.92 1.16 9.30 0.5 0.5 2 0.5 ## 4 Hornet 4 D… 10.7 3 129 55 1.54 1.61 9.72 0.5 0 1.5 0.5 ## 5 Hornet Spo… 9.35 4 180 87.5 1.58 1.72 8.51 0 0 1.5 1 ## 6 Valiant 9.05 3 112. 52.5 1.38 1.73 10.1 0.5 0 1.5 0.5 ## 7 Duster 360 7.15 4 180 122. 1.60 1.78 7.92 0 0 1.5 2 ## 8 Merc 240D 12.2 2 73.4 31 1.84 1.60 10 0.5 0 2 1 ## 9 Merc 230 11.4 2 70.4 47.5 1.96 1.58 11.4 0.5 0 2 1 ## 10 Merc 280 9.6 3 83.8 61.5 1.96 1.72 9.15 0.5 0 2 2 ## # … with 22 more rows 3.2 Iterating over lists The usefulness of iteration is more apparent when we’re working with grouped data. I’ve covered a bit of this in the previous chapter, but this is when we’ve split the data based on some sort of a categorical variable. mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) The member of the apply family suited for this task is lapply() which returns a list: lapply(mtcars_lst, function(x) cor(x$mpg, x$wt)) ## [[1]] ## [1] -0.7131848 ## ## [[2]] ## [1] -0.6815498 ## ## [[3]] ## [1] -0.650358 Of course, we can define our own function and then pass it over to lapply() instead: get_pval &lt;- function(x){ mod &lt;- cor.test(x$mpg, x$wt) pv &lt;- mod$p.value if (pv &lt; 0.05){ is_sig &lt;- TRUE } else { is_sig &lt;- FALSE } return(is_sig) } lapply(mtcars_lst, get_pval) ## [[1]] ## [1] TRUE ## ## [[2]] ## [1] FALSE ## ## [[3]] ## [1] TRUE Using vapply() instead allows you to define the class of what the expected output would be: vapply(mtcars_lst, get_pval, FUN.VALUE = logical(1)) ## [1] TRUE FALSE TRUE purrr::map solution to iterating over list is as such: mtcars_lst %&gt;% map(~ cor(.x$mpg, .x$wt)) ## [[1]] ## [1] -0.7131848 ## ## [[2]] ## [1] -0.6815498 ## ## [[3]] ## [1] -0.650358 If we want the output to be a flat numeric vector instead of a list: mtcars_lst %&gt;% map_dbl(~ cor(.x$mpg, .x$wt)) ## [1] -0.7131848 -0.6815498 -0.6503580 Similarly, using map_lgl instead would return a logical vector: mtcars_lst %&gt;% map_lgl(get_pval) ## [1] TRUE FALSE TRUE Iterations are also useful when we want to generate visualizations based on the grouped split: p &lt;- mtcars_lst %&gt;% map(~ ggplot(data = .x, aes(x = mpg, y = wt)) + geom_point() + geom_smooth(method = &#39;lm&#39;) + theme_bw()) p[[1]] p[[3]] Combining the package broom with iterative model fitting is particularly useful: library(broom) mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(glance) %&gt;% bind_rows() ## # A tibble: 3 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.115 0.0163 4.47 1.17 0.308 1 -31.0 68.0 69.2 ## 2 0.0000902 -0.200 1.59 0.000451 0.984 1 -12.0 30.0 29.9 ## 3 0.00246 -0.0807 2.66 0.0297 0.866 1 -32.5 71.0 72.9 ## # … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; Using lapply() instead: lapply(mtcars_lst, function(x) lm(mpg ~ gear, data = x)) %&gt;% lapply(glance) %&gt;% bind_rows() ## # A tibble: 3 x 12 ## r.squared adj.r.squared sigma statistic p.value df logLik AIC BIC ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 0.115 0.0163 4.47 1.17 0.308 1 -31.0 68.0 69.2 ## 2 0.0000902 -0.200 1.59 0.000451 0.984 1 -12.0 30.0 29.9 ## 3 0.00246 -0.0807 2.66 0.0297 0.866 1 -32.5 71.0 72.9 ## # … with 3 more variables: deviance &lt;dbl&gt;, df.residual &lt;int&gt;, nobs &lt;int&gt; The map() function can also be used to extract elements: mtcars_lst %&gt;% map(&#39;CAR&#39;) ## [[1]] ## [1] &quot;Datsun 710&quot; &quot;Merc 240D&quot; &quot;Merc 230&quot; &quot;Fiat 128&quot; ## [5] &quot;Honda Civic&quot; &quot;Toyota Corolla&quot; &quot;Toyota Corona&quot; &quot;Fiat X1-9&quot; ## [9] &quot;Porsche 914-2&quot; &quot;Lotus Europa&quot; &quot;Volvo 142E&quot; ## ## [[2]] ## [1] &quot;Mazda RX4&quot; &quot;Mazda RX4 Wag&quot; &quot;Hornet 4 Drive&quot; &quot;Valiant&quot; ## [5] &quot;Merc 280&quot; &quot;Merc 280C&quot; &quot;Ferrari Dino&quot; ## ## [[3]] ## [1] &quot;Hornet Sportabout&quot; &quot;Duster 360&quot; &quot;Merc 450SE&quot; ## [4] &quot;Merc 450SL&quot; &quot;Merc 450SLC&quot; &quot;Cadillac Fleetwood&quot; ## [7] &quot;Lincoln Continental&quot; &quot;Chrysler Imperial&quot; &quot;Dodge Challenger&quot; ## [10] &quot;AMC Javelin&quot; &quot;Camaro Z28&quot; &quot;Pontiac Firebird&quot; ## [13] &quot;Ford Pantera L&quot; &quot;Maserati Bora&quot; mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(coef) %&gt;% map_dbl(2) ## [1] 2.83125 -0.02000 0.17500 3.3 Iterating over vectors Let’s say we have a vector with missing values: x &lt;- c(3, 2, NA, 2, 1, 4, 2, NA, 2, NA) x ## [1] 3 2 NA 2 1 4 2 NA 2 NA Filling the missing values is easy with iteration over the length of the vector: x %&gt;% map_dbl(~ replace(., is.na(.x), 0)) ## [1] 3 2 0 2 1 4 2 0 2 0 Or if we want to replace the missing values with the mean: x %&gt;% map_dbl(~ replace(., is.na(.x), mean(x, na.rm = TRUE))) ## [1] 3.000000 2.000000 2.285714 2.000000 1.000000 4.000000 2.000000 2.285714 ## [9] 2.000000 2.285714 This can of course be done with a for loop instead: for (i in seq_along(x)){ if (is.na(x[i]) == TRUE){ x[i] &lt;- mean(x, na.rm = TRUE) } } x ## [1] 3.000000 2.000000 2.285714 2.000000 1.000000 4.000000 2.000000 2.285714 ## [9] 2.000000 2.285714 Note that seq_along(x) prints the indices along the length of the vector, as if to write 1:length(x). Iterating over a vector of characters requires map_chr() to get the character vector back, but the syntax is the same: z &lt;- c(&#39;Brian&#39;, &#39;Connor&#39;, &#39;Harry&#39;, &#39;Sonny&#39;) map_chr(z, ~ paste0(.x, &#39;_NAME&#39;)) ## [1] &quot;Brian_NAME&quot; &quot;Connor_NAME&quot; &quot;Harry_NAME&quot; &quot;Sonny_NAME&quot; out &lt;- character(length(z)) for (i in seq_along(z)){ out[i] &lt;- paste0(z[i], &#39;_NAME&#39;) } out ## [1] &quot;Brian_NAME&quot; &quot;Connor_NAME&quot; &quot;Harry_NAME&quot; &quot;Sonny_NAME&quot; In particular cases where the output is printed out, as in the case of print() and cat(), we may end up echoing both the return values and the output list when using map(). To that end, walk() is used to avoid showing the result twice: walk(z, ~ print(paste0(.x, &#39;_NAME&#39;))) ## [1] &quot;Brian_NAME&quot; ## [1] &quot;Connor_NAME&quot; ## [1] &quot;Harry_NAME&quot; ## [1] &quot;Sonny_NAME&quot; 3.4 Iterating with two inputs In contrast to every solution so far, there’s a case to be made about iterating over multiple inputs. For that purpose, purrr:map2 does the job. x &lt;- c(2, 4, 2, 5) y &lt;- c(2, 6, 3, 1) map2_dbl(x, y, sum) ## [1] 4 10 5 6 map2_chr(x, y, ~ str_glue(&#39;The sum of {.x} and {.y} is {sum(.x, .y)}&#39;)) ## [1] &quot;The sum of 2 and 2 is 4&quot; &quot;The sum of 4 and 6 is 10&quot; ## [3] &quot;The sum of 2 and 3 is 5&quot; &quot;The sum of 5 and 1 is 6&quot; Note that the iteration occurs at the ith position of each vector. The intuition behind map2() is straightforward and is illustrated by the equivalent for loop: result &lt;- numeric(length(x)) for (i in seq_along(x)){ result[i] &lt;- sum(x[i], y[i]) } result ## [1] 4 10 5 6 One quirk with map2() is that it recycles the input: map2_chr(&#39;My name is &#39;, c(&#39;Brian&#39;, &#39;Connor&#39;), str_c) ## [1] &quot;My name is Brian&quot; &quot;My name is Connor&quot; Suppose a dataset such as this: z &lt;- tibble(A = x, B = y) z ## # A tibble: 4 x 2 ## A B ## &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2 ## 2 4 6 ## 3 2 3 ## 4 5 1 There may be cases where we want to create a new column using mutate() which results from a transformation of the A and B columns at each row. First, see why the following does not work in creating a column C which takes the higher value between A and B at each row: z %&gt;% mutate(C = max(A, B)) ## # A tibble: 4 x 3 ## A B C ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2 6 ## 2 4 6 6 ## 3 2 3 6 ## 4 5 1 6 Using map2(), however, this does work: z %&gt;% mutate(C = map2_dbl(A, B, max)) ## # A tibble: 4 x 3 ## A B C ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2 2 ## 2 4 6 6 ## 3 2 3 3 ## 4 5 1 5 Other families of map2() works normally in this context, for example, if we want to check whether the sum of A and B at each row is an even number: z %&gt;% mutate(C = map2_lgl(A, B, ~ (.x + .y) %% 2 == 0)) ## # A tibble: 4 x 3 ## A B C ## &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2 2 TRUE ## 2 4 6 TRUE ## 3 2 3 FALSE ## 4 5 1 TRUE When there are more than 2 inputs, we can use pmap() instead; this function takes a list of the inputs instead: w &lt;- c(4, 2, 3, 1) pmap_dbl(list(x, y, w), sum) ## [1] 8 12 8 7 z &lt;- tibble(A = x, B = y, C = w) z ## # A tibble: 4 x 3 ## A B C ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 2 2 4 ## 2 4 6 2 ## 3 2 3 3 ## 4 5 1 1 z %&gt;% mutate(v = pmap_lgl(list(A, B, C), ~ sum(.) %% 2 == 0)) ## # A tibble: 4 x 4 ## A B C v ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2 2 4 TRUE ## 2 4 6 2 TRUE ## 3 2 3 3 TRUE ## 4 5 1 1 FALSE Using the notation for anonymous functions instead: z %&gt;% mutate(v = pmap_lgl(list(A, B, C), ~ sum(..1 + ..2 + ..3) %% 2 == 0)) ## # A tibble: 4 x 4 ## A B C v ## &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;lgl&gt; ## 1 2 2 4 TRUE ## 2 4 6 2 TRUE ## 3 2 3 3 TRUE ## 4 5 1 1 FALSE 3.5 Iterating over indices and names A related function is imap() and its variants, which is analogous to looping over numeric indices, such as in the case of for (i in seq_along(x)). That is, it applies a function over an input and its corresponding index. For example: x &lt;- c(2, 4, 2, 5) imap_chr(x, ~ paste0(&#39;The index &#39;, .y, &#39; number in x is &#39;, .x)) ## [1] &quot;The index 1 number in x is 2&quot; &quot;The index 2 number in x is 4&quot; ## [3] &quot;The index 3 number in x is 2&quot; &quot;The index 4 number in x is 5&quot; Without using purrr, this is equivalent to the for loop: out &lt;- character(length(x)) for (i in seq_along(x)){ out[i] &lt;- paste0(&#39;The index &#39;, i, &#39; number in x is &#39;, x[i]) } out ## [1] &quot;The index 1 number in x is 2&quot; &quot;The index 2 number in x is 4&quot; ## [3] &quot;The index 3 number in x is 2&quot; &quot;The index 4 number in x is 5&quot; imap also works with names instead of indices, if required: names(x) &lt;- c(&#39;A&#39;, &#39;B&#39;, &#39;C&#39;, &#39;D&#39;) imap_lgl(x, ~ if(.y %in% c(&#39;A&#39;, &#39;C&#39;)) TRUE else FALSE) ## A B C D ## TRUE FALSE TRUE FALSE The equivalent expression in the form of a for loop is as follows: out &lt;- logical() for (i in names(x)){ if(i %in% c(&#39;A&#39;, &#39;C&#39;)){ out[i] &lt;- TRUE } else { out[i] &lt;- FALSE } } out ## A B C D ## TRUE FALSE TRUE FALSE Therefore, we see clearly that the two uses of imap() - iterating over indices and over names - is equivalent to for (i in seq_along(x)) and for (i in names(x)), respectively. 3.6 Handling errors within purrr Let’s return to the mtcars dataset, specifically after we split the tibble into a list based on group_split(cyl). mtcars_lst &lt;- mtcars %&gt;% group_split(cyl) For one of the elements of the list, I’m filling the gear column with missing values: mtcars_lst[[2]] &lt;- mtcars_lst[[2]] %&gt;% mutate(gear = NA) mtcars_lst[[2]] ## # A tibble: 7 x 12 ## CAR mpg cyl disp hp drat wt qsec vs am gear carb ## &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 Mazda RX4 21 6 160 110 3.9 2.62 16.5 0 1 NA 4 ## 2 Mazda RX4 W… 21 6 160 110 3.9 2.88 17.0 0 1 NA 4 ## 3 Hornet 4 Dr… 21.4 6 258 110 3.08 3.22 19.4 1 0 NA 1 ## 4 Valiant 18.1 6 225 105 2.76 3.46 20.2 1 0 NA 1 ## 5 Merc 280 19.2 6 168. 123 3.92 3.44 18.3 1 0 NA 4 ## 6 Merc 280C 17.8 6 168. 123 3.92 3.44 18.9 1 0 NA 4 ## 7 Ferrari Dino 19.7 6 145 175 3.62 2.77 15.5 0 1 NA 6 Now, if I were to try and fit a linear model using lm(mpg ~ wt) iteratively over the mtcars_lst, it will fail at the second element as the wt values are all missing. mtcars_lst %&gt;% map(~ lm(mpg ~ gear, data = .x)) %&gt;% map(coef) %&gt;% map_dbl(2) # returns an error This is inconvenient in many cases as ideally we’d want to skip over the iteration at which the function fails and get the rest of the results. Thankfully this can be done using possibly(); note the second element in the output where the lm() function would’ve failed: map(mtcars_lst, possibly(~ lm(mpg ~ gear, data = .x), otherwise = NA)) ## [[1]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 15.081 2.831 ## ## ## [[2]] ## [1] NA ## ## [[3]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 14.525 0.175 The second argument within otherwise = argument within possibly(), where we wrapped the iterative function, provides an alternative solution in case the function fails. As we can see above, the second element of the output corresponds to NA and the iteration continued after. Using purrr::keep() I can select for the elements that did not fail: map(mtcars_lst, possibly(~ lm(mpg ~ gear, data = .x), otherwise = NA)) %&gt;% keep(~ !is.na(.x) %&gt;% all()) ## [[1]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 15.081 2.831 ## ## ## [[2]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 14.525 0.175 Of course this is the same as running the first map() function wrapped around possibly() and then running result[-which(is.na(result)]. Sometimes it’s not useful to keep the failed element in the first place, so setting otherwise = NULL within possibly() works too. Afterwards, removing the empty element (i.e., NULL) is done using purrr::compact(). map(mtcars_lst, possibly(~ lm(mpg ~ gear, data = .x), otherwise = NULL)) %&gt;% compact() ## [[1]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 15.081 2.831 ## ## ## [[2]] ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 14.525 0.175 Instead of discarding the iteration where the function failed, we could also catch the error by using safely() instead. This returns a nested list as such: map(mtcars_lst, safely(~ lm(mpg ~ gear, data = .x))) ## [[1]] ## [[1]]$result ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 15.081 2.831 ## ## ## [[1]]$error ## NULL ## ## ## [[2]] ## [[2]]$result ## NULL ## ## [[2]]$error ## &lt;simpleError in lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...): 0 (non-NA) cases&gt; ## ## ## [[3]] ## [[3]]$result ## ## Call: ## lm(formula = mpg ~ gear, data = .x) ## ## Coefficients: ## (Intercept) gear ## 14.525 0.175 ## ## ## [[3]]$error ## NULL We could also just pull the error terms and throw away the empty NULL elements: map(mtcars_lst, safely(~ lm(mpg ~ gear, data = .x))) %&gt;% map(&#39;error&#39;) %&gt;% compact() ## [[1]] ## &lt;simpleError in lm.fit(x, y, offset = offset, singular.ok = singular.ok, ...): 0 (non-NA) cases&gt; In a traditional for loop without purrr, a solution could be to use tryCatch() with next. Below returns the iteration with the error as NULL as was the case with possibly(..., otherwise = NULL). mod &lt;- list() for (i in seq_along(mtcars_lst)){ err &lt;- tryCatch( mod[[i]] &lt;- lm(mpg ~ gear, data = mtcars_lst[[i]]), error = function(e) e ) if (inherits(err, &#39;error&#39;)) next mod[[i]] &lt;- lm(mpg ~ gear, data = mtcars_lst[[i]]) } mod ## [[1]] ## ## Call: ## lm(formula = mpg ~ gear, data = mtcars_lst[[i]]) ## ## Coefficients: ## (Intercept) gear ## 15.081 2.831 ## ## ## [[2]] ## NULL ## ## [[3]] ## ## Call: ## lm(formula = mpg ~ gear, data = mtcars_lst[[i]]) ## ## Coefficients: ## (Intercept) gear ## 14.525 0.175 "],["interlude-i-a-brief-glimpse-into-data.html", "Chapter 4 Interlude I: A brief glimpse into data.table 4.1 Data wrangling operations 4.2 .SD, .SDcols, and := 4.3 Reshaping data using melt and dcast", " Chapter 4 Interlude I: A brief glimpse into data.table In the first chapter, we saw various practical solutions in data wrangling using tidyverse and base R. One topic that has not been discussed is the idea of computational efficiency and runtime - this matter has been trivial so far since the datasets have been considerably tiny. However, when working with large data, it may be in the user’s interest to try using an alternative package designed for reducing programming and computation time - data.table. The vignette is available here. library(data.table) options(datatable.print.nrows=10) Similarly to how a tibble is an enhanced form of a data.frame in tidyverse, data.table uses an object class called a data.table. Using fread() to read in data - whether the argument corresponds to a local file or a URL pointing to a dataset - automatically generates a data.table object. Converting a regular data.frame to a data.table is done with setDT(). data(mtcars) setDT(mtcars) head(mtcars, 10) ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1: 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2: 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3: 22.8 4 108.0 93 3.85 2.320 18.61 1 1 4 1 ## 4: 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 5: 18.7 8 360.0 175 3.15 3.440 17.02 0 0 3 2 ## 6: 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 7: 14.3 8 360.0 245 3.21 3.570 15.84 0 0 3 4 ## 8: 24.4 4 146.7 62 3.69 3.190 20.00 1 0 4 2 ## 9: 22.8 4 140.8 95 3.92 3.150 22.90 1 0 4 2 ## 10: 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 class(mtcars)[1] ## [1] &quot;data.table&quot; 4.1 Data wrangling operations The vignette does a great job explaining the syntax of data.table in detail, but the takeaway message is that it subsets the data by i, performs an operation according to j, then groups it using by =. That is, DT[i, j, by]. mtcars[cyl == 6, .(mean_mileage = mean(mpg))] ## mean_mileage ## 1: 19.74286 Above, data.table has subsetted the object based on cyl == 6 then calculated the mean mileage. The j is wrapped around .(), which is equivalent to list() - this is because the columns in a table are analogous to a list object and we want to return a data.table as our output rather than an atomic vector. class(mtcars[cyl == 6, .(mean_mileage = mean(mpg))]) ## [1] &quot;data.table&quot; &quot;data.frame&quot; Multiple calculations can be performed in j: mtcars[cyl == 6 &amp; gear == 4, .(mean_mileage = mean(mpg), median_wt = median(wt))] ## mean_mileage median_wt ## 1: 19.75 3.1575 Calculating the number of rows in j uses a special variable .N. mtcars[cyl == 6 &amp; gear == 4, .N] ## [1] 4 The j argument can be used to select columns after subsetting rows with i; this is analogous to filter() and select() in dplyr: mtcars[, .(mpg, wt, gear)][1:10] ## mpg wt gear ## 1: 21.0 2.620 4 ## 2: 21.0 2.875 4 ## 3: 22.8 2.320 4 ## 4: 21.4 3.215 3 ## 5: 18.7 3.440 3 ## 6: 18.1 3.460 3 ## 7: 14.3 3.570 3 ## 8: 24.4 3.190 4 ## 9: 22.8 3.150 4 ## 10: 19.2 3.440 4 my_cols &lt;- c(&#39;mpg&#39;, &#39;wt&#39;, &#39;gear&#39;) mtcars[, ..my_cols][1:10] ## mpg wt gear ## 1: 21.0 2.620 4 ## 2: 21.0 2.875 4 ## 3: 22.8 2.320 4 ## 4: 21.4 3.215 3 ## 5: 18.7 3.440 3 ## 6: 18.1 3.460 3 ## 7: 14.3 3.570 3 ## 8: 24.4 3.190 4 ## 9: 22.8 3.150 4 ## 10: 19.2 3.440 4 Using by = argument is similar to group_by() in dplyr: mtcars[, .(mean_mileage = mean(mpg), median_wt = median(wt)), by = cyl] ## cyl mean_mileage median_wt ## 1: 6 19.74286 3.215 ## 2: 4 26.66364 2.200 ## 3: 8 15.10000 3.755 mtcars[, .N, by = cyl] ## cyl N ## 1: 6 7 ## 2: 4 11 ## 3: 8 14 mtcars[vs == 0, .N, by = .(cyl, gear)] ## cyl gear N ## 1: 6 4 2 ## 2: 8 3 12 ## 3: 4 5 1 ## 4: 8 5 2 ## 5: 6 5 1 Piping multiple operations together in data.table is straightforward: mtcars[vs == 0, .(mpg, cyl, gear)][,.(mean_mpg = mean(mpg)), by = .(cyl, gear)] ## cyl gear mean_mpg ## 1: 6 4 21.00 ## 2: 8 3 15.05 ## 3: 4 5 26.00 ## 4: 8 5 15.40 ## 5: 6 5 19.70 4.2 .SD, .SDcols, and := For slightly more difficult operations, we need to define three new concepts: firstly, the .SD variable points to the current subset of data. mtcars[cyl == 6, .SD] ## mpg cyl disp hp drat wt qsec vs am gear carb ## 1: 21.0 6 160.0 110 3.90 2.620 16.46 0 1 4 4 ## 2: 21.0 6 160.0 110 3.90 2.875 17.02 0 1 4 4 ## 3: 21.4 6 258.0 110 3.08 3.215 19.44 1 0 3 1 ## 4: 18.1 6 225.0 105 2.76 3.460 20.22 1 0 3 1 ## 5: 19.2 6 167.6 123 3.92 3.440 18.30 1 0 4 4 ## 6: 17.8 6 167.6 123 3.92 3.440 18.90 1 0 4 4 ## 7: 19.7 6 145.0 175 3.62 2.770 15.50 0 1 5 6 In above context, the .SD doesn’t do much. but this special variable is useful when you’re doing operations over multiple columns. Using .SDcols with .SD allows user to specifically point to columns across the current subset of data. mtcars[cyl == 6, .SD, .SDcols = c(&#39;disp&#39;, &#39;hp&#39;, &#39;drat&#39;)] ## disp hp drat ## 1: 160.0 110 3.90 ## 2: 160.0 110 3.90 ## 3: 258.0 110 3.08 ## 4: 225.0 105 2.76 ## 5: 167.6 123 3.92 ## 6: 167.6 123 3.92 ## 7: 145.0 175 3.62 This means we can easily perform operations across a subset of columns: mtcars[, lapply(.SD, mean), by = cyl, .SDcols = c(&#39;disp&#39;, &#39;hp&#39;, &#39;drat&#39;)] ## cyl disp hp drat ## 1: 6 183.3143 122.28571 3.585714 ## 2: 4 105.1364 82.63636 4.070909 ## 3: 8 353.1000 209.21429 3.229286 .SDcols is flexible because it also accepts indices: col_idx &lt;- colnames(mtcars) %in% c(&#39;disp&#39;, &#39;hp&#39;, &#39;drat&#39;) mtcars[, lapply(.SD, mean), by = cyl, .SDcols = col_idx] ## cyl disp hp drat ## 1: 6 183.3143 122.28571 3.585714 ## 2: 4 105.1364 82.63636 4.070909 ## 3: 8 353.1000 209.21429 3.229286 Using the := operator allows user to define new columns in one of two ways: firstly, in a simple LHS := RHS syntax; this creates a new column but does not print the result to the console. mtcars[, HpPerMpg := .(hp/mpg)] head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb HpPerMpg ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 5.238095 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 5.238095 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4.078947 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5.140187 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 9.358289 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 5.801105 This allows users to remove columns by setting the RHS to NULL: # not run mtcars[, HpPerMpg := NULL] Subsetting using i allows for condition-based operations, similar to mutate(case_when()) in dplyr: mtcars[cyl == 6, CylThreshold := &#39;Over 6&#39;][cyl != 6, CylThreshold := &#39;Under 6&#39;] head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb HpPerMpg CylThreshold ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 5.238095 Over 6 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 5.238095 Over 6 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4.078947 Under 6 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5.140187 Over 6 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 9.358289 Under 6 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 5.801105 Over 6 Secondly, := can be used in a functional form: mtcars[, `:=`(HpPerMpg = hp/mpg, MpgXCyl = mpg*cyl)] head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb HpPerMpg CylThreshold ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 5.238095 Over 6 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 5.238095 Over 6 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4.078947 Under 6 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5.140187 Over 6 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 9.358289 Under 6 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 5.801105 Over 6 ## MpgXCyl ## 1: 126.0 ## 2: 126.0 ## 3: 91.2 ## 4: 128.4 ## 5: 149.6 ## 6: 108.6 Combining the := with by =: mtcars[, `:=`(mean_mileage = mean(mpg)), by = .(cyl, vs)] head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb HpPerMpg CylThreshold ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 5.238095 Over 6 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 5.238095 Over 6 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4.078947 Under 6 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5.140187 Over 6 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 9.358289 Under 6 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 5.801105 Over 6 ## MpgXCyl mean_mileage ## 1: 126.0 20.56667 ## 2: 126.0 20.56667 ## 3: 91.2 26.73000 ## 4: 128.4 19.12500 ## 5: 149.6 15.10000 ## 6: 108.6 19.12500 Combining .SD with the := operator: mtcars[, c(&#39;max_disp&#39;, &#39;max_hp&#39;, &#39;max_wt&#39;) := lapply(.SD, max), by = cyl, .SDcols = c(&#39;disp&#39;, &#39;hp&#39;, &#39;wt&#39;)] head(mtcars) ## mpg cyl disp hp drat wt qsec vs am gear carb HpPerMpg CylThreshold ## 1: 21.0 6 160 110 3.90 2.620 16.46 0 1 4 4 5.238095 Over 6 ## 2: 21.0 6 160 110 3.90 2.875 17.02 0 1 4 4 5.238095 Over 6 ## 3: 22.8 4 108 93 3.85 2.320 18.61 1 1 4 1 4.078947 Under 6 ## 4: 21.4 6 258 110 3.08 3.215 19.44 1 0 3 1 5.140187 Over 6 ## 5: 18.7 8 360 175 3.15 3.440 17.02 0 0 3 2 9.358289 Under 6 ## 6: 18.1 6 225 105 2.76 3.460 20.22 1 0 3 1 5.801105 Over 6 ## MpgXCyl mean_mileage max_disp max_hp max_wt ## 1: 126.0 20.56667 258.0 175 3.460 ## 2: 126.0 20.56667 258.0 175 3.460 ## 3: 91.2 26.73000 146.7 113 3.190 ## 4: 128.4 19.12500 258.0 175 3.460 ## 5: 149.6 15.10000 472.0 335 5.424 ## 6: 108.6 19.12500 258.0 175 3.460 Finally, a strange behaviour is observed when we start making copies of data; for example: data(iris) setDT(iris) iris2 &lt;- iris identical(iris, iris2) ## [1] TRUE Now see what happens when we change one of the columns in iris2 using :=: iris2[, Petal.Width := Petal.Width/100] iris2 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1: 5.1 3.5 1.4 0.002 setosa ## 2: 4.9 3.0 1.4 0.002 setosa ## 3: 4.7 3.2 1.3 0.002 setosa ## 4: 4.6 3.1 1.5 0.002 setosa ## 5: 5.0 3.6 1.4 0.002 setosa ## --- ## 146: 6.7 3.0 5.2 0.023 virginica ## 147: 6.3 2.5 5.0 0.019 virginica ## 148: 6.5 3.0 5.2 0.020 virginica ## 149: 6.2 3.4 5.4 0.023 virginica ## 150: 5.9 3.0 5.1 0.018 virginica It turns out that changing iris2 has also changed the original data iris: head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1: 5.1 3.5 1.4 0.002 setosa ## 2: 4.9 3.0 1.4 0.002 setosa ## 3: 4.7 3.2 1.3 0.002 setosa ## 4: 4.6 3.1 1.5 0.002 setosa ## 5: 5.0 3.6 1.4 0.002 setosa ## 6: 5.4 3.9 1.7 0.004 setosa identical(iris, iris2) ## [1] TRUE However, if we use &lt;- to change one of the columns of iris2, the original iris data does not change: iris2$Petal.Length &lt;- iris2$Petal.Length/100 identical(iris, iris2) ## [1] FALSE The rationale for this behaviour is well-explained in this stackoverflow post, but essentially what happens is that := operator modifies by reference. Both iris2 and iris are pointing to the same location after copying initially with &lt;-. Thus when we modify the copy of iris by reference, there is no need to copy the entire dataset iris to alter its copy. On the other hand, changing iris2 using &lt;- will copy the entire thing even if we’re only changing just one column. This behaviour is undesirable when we’re working with very large data. To avoid changing the original dataset but still use := to update a copy, data.table uses the copy() function: iris3 &lt;- copy(iris) iris3[, Petal.Width := Petal.Width/100] identical(iris, iris3) # only the iris3 object was changed here ## [1] FALSE 4.3 Reshaping data using melt and dcast In the first chapter, I briefly touched on melt() as an alternative to tidr::pivot_longer(). Base R’s equivalent reshape() is rather clunky to use, so I much prefer the tidyr or data.table solutions. DT &lt;- data.table( Team = c(&#39;Tottenham&#39;, &#39;Arsenal&#39;, &#39;Chelsea&#39;, &#39;ManUnited&#39;), Wins = c(7, 3, 4, 6), Goals = c(29, 18, 22, 26), CleanSheets = c(3, 1, 2, 3) ) DT ## Team Wins Goals CleanSheets ## 1: Tottenham 7 29 3 ## 2: Arsenal 3 18 1 ## 3: Chelsea 4 22 2 ## 4: ManUnited 6 26 3 DT_long &lt;- melt(DT, id.vars = &#39;Team&#39;, measure.vars = c(&#39;Wins&#39;, &#39;Goals&#39;, &#39;CleanSheets&#39;), variable.name = &#39;Stat&#39;, value.name = &#39;Value&#39;) DT_long ## Team Stat Value ## 1: Tottenham Wins 7 ## 2: Arsenal Wins 3 ## 3: Chelsea Wins 4 ## 4: ManUnited Wins 6 ## 5: Tottenham Goals 29 ## --- ## 8: ManUnited Goals 26 ## 9: Tottenham CleanSheets 3 ## 10: Arsenal CleanSheets 1 ## 11: Chelsea CleanSheets 2 ## 12: ManUnited CleanSheets 3 The data.table equivalent to tidyr::pivot_wider() is dcast(); this function takes in a formula as an argument (~) where the LHS corresponds to the id.vars and the RHS corresponds to the column that originated from the measure.vars. Running this yields the original dataset: dcast(DT_long, Team ~ Stat, value.var = &#39;Value&#39;) ## Team Wins Goals CleanSheets ## 1: Arsenal 3 18 1 ## 2: Chelsea 4 22 2 ## 3: ManUnited 6 26 3 ## 4: Tottenham 7 29 3 "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
